# Что нужно умень делать при разработке композиции элементов пользовательского интерфейса

Композиция - сборка сложного пользовательского интерфейса из множества простых элементов. Композиция яаще всего является многоуровневой, т.е. многие элементы распологаются на одном уровне, являясь соседними, или родственными (siblings), а многие другие связаны в иерархию, ч.е. часть из них является родительскими элементами, а часть дочерними.

При создании композиции именно иерахически связанные элементы представляют самую сложную часть дизайна приложения.

Типовые проблемы в композиции элементов:

- Низкая производительность, когда изменении родительского элемента приводит к повторному рендерингу множества дочерних элементов (производительность)
- Высокая сложность отдельных компонентов (сложность)
- Взаимозависимость компонентов между которыми есть иерархические уровни (сложность, производительность)
- Взаимозависимость компонентов находящихся в разных дочерних иерархиях (сложность)

Какие шаблоны программирования нужно знать, чтобы эффективно создавать композиции в любых Framework-ах?

1. Передача параметров от родительского элемента дочерним. Часто для обратной передачи данных (результатов) используется передача callback-функций в качестве параметров.

2. Группировка параметров для передачи компонентам, располагающимся ниже в иерархии. В React используется spread/rest operator, Например:

```js
export default function Button({children, mode = 'filled', Icon, ...rest}) {
  // ...
  return (
    <button className="{cla} icon-button" {...rest}>
        {Icon && (<span className="button-icon">{Icon()}</span>)}
        <span>{children}</span>
    </button>
    );
}
```

3. Передача верстки в дочерний компонент через специализированное свойство. В React используется специальное свойство children. Приведённый выше пример показывает, как в верстку дочернего компонента встраивается верстка определённая в родительском компоненте. Пример использования дочернего компонента:

```js
<button onClick={handleClick}>
    Clicked {count} times
</button>
```

4. Передача верстки в дочерний элемент через произвольное свойство. Часто используется для дополнительной настройки пользовательского интерфейса. Пример приведён в пункте 2 - через параметр Icon может быть передан произвольный компонент, например, компонент отрисоывающий SVG-иконку. Однако это может быть что-угодно, включая произвольную верстку.

Важно иметь ввиду, что в этой вертке может быть реализована работа с состояниями, определёнными в родительском компоненте. Пример: есть страница с контентом, в которую встраивается поле ввода почты пользователя и кнопка Submit. Обработка нажатия кнопки будет осуществляться в родительском компоненте. Такой способ внедрения удобен в том случае, если родительский компонент знает о том, добавили ли пользователь подписку на новости, или нет, но не хочет, чтобы дочерний компонент знал об этом. Это своего рода, инкапсуляция.

5. В общем случае, при изменении родительского компонента происходит ре-рендеринг дочерних компонентов, что может быть вычислительно затратным. Чтобы исключить не изменившиеся дочерние компоненты из ре-рендеринга может использоваться **Мемоизация**, т.к. условное кэширование. Если количество не изменяемых, или редко изменяемых дочерних компонентов большое, то мемоизация может быть очень значительное ускорение рендеринга.

6. **Контекст** позволяет связать изменение в одном дочернем компоненте с изменениями других дочерних компонентов (причём на разных уровнях иерархии), через родительский компонент. В React для этой задачи используется хук `useContext`.

7. Эффективное выполнения условного рендеринга. Вместо эффективности, могут использоваться и другие подходы: канонический (понятно другим людям), идеоматическим (соответствует принятым в инструменте идиомам). Пример из React:

```js
{Icon && (<span className="button-icon">{Icon()}</span>)}
```

В данном случае, если Icon будет равен null, или undefined, то в верстку не будет добавлена группа HTML-тэгов. Это не очевидная синтаксическая конструкция, но идеоматическая.

8. Существует множество ситуация, когда композиция не подходит для решения задачи. При разработке web-приложений важно понимать, когда необъодимо остановиться и не применять устояшуюся практику к конкретному случаю. Пример - форма, на которой используется множество дочерних элементов с абсолютным позиционированием. В компонентной модели изменение положения одного дочернего компонента может приводить к изменению состояния родительского компонента и ре-рендерингу всех дочерних компонентов, что может быть лишено какого-либо смысла.
