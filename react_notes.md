# Заметки об использовании React

Начать нужно с того, что делает React (или Blazor, или другой инструмент, реализующий декларативное программирование), по сути, безальтернативным при разработке web-приложений.

Ключевым для обеспечения качества работы приложения является его умение контролировать изменение состояния. В случае, если мы используем Vanilla JavaScript, изменение состояния носит хаотичный характер. Управление добавлением, или удалением элементов, подписок, и т.д., крайне сложно надёжно реализовать вручную.

Обычно, код написанный на Vanilla JavaScript является очень хрупким. Основные проблемы:

- **Unsafe**: обработчик некоторого события (например, нажатия на кнопку) может быть легко переопределён другим JavaScript-кодов на странице. Чтобы избежать этого мы можем использовать addEventListener, но в этом случае мы должны аккуратно вызывать removeEventListener, чтобы избежать утечки ресурсов и замедления работы приложения
- **Unpredicatable**: в случае большого объёма верстки можно легко ошибиться в написании идентификатора и, в частности, получить коллизию имён элементов DOM, которая может быть обнаружена в очень редких случаях
- **Inefficient**: операция изменения DOM (_mutation_) является очень дорогой и кажется важным накапливать изменения и осуществлять их одной большой операцией, а не множеством мелких операций

React решает приведённые выше проблемы, добавляя к этому возможности применения императивного программирования. Преимущество подхода состоит в том, что используя JSX (Javascript Syntax eXtension) мы описывам то, что мы хотем увидеть, а не то, как мы достигаем результата.

>Для всех файлов с расширениями ".jsx" и ".tsx" применяется JSX-транспайлер, который применяет токенайзер (lexer) для выделения отдельных токенов в файле, затем осуществляет парсинг выполняя построение **синтаксического дерева**, которое можно представить в виде JSON-документа. На следующем этапе, осуществляется генерация JavaScript-кода, соответствующего содержимому синтаксического дерева.
>
>Таким образом мы переходим от конструкции `(<Box prop="value">Ящик</Box>)` к JavaScript-коду `React.createElement(Box, {prop: "value"}, "contents");`.
>
>Здесь возникают следующие потери:
>
>- транспиляция требует времени и цепочка транспиляции может быть большой (TSX -> TypeScript, TypeScript -> JavaScript)
>- трансляция JavaScript в браузере, может значительно влиять на время запуска приложения

Ключевые техники оптимизации React-приложений связаны с уменьшением количества re-rendering-а, что достигается уменьшением количества изменений состояния функциональных компонентов. Чаще всего применяются: мемоизация (определение неизменяемых компонентов и элементов верстки), применением вычисляемых "состояний", а также производных (derived) "состояний". Последние два пункта не являются состояниями, а имитируют их, используя другие реальные состояния в системе.

### Почему Custom Components начинаются с заглавной буквы

React смотрит на регистр первой буквы в имени компонент и принимает решение о том, является ли компонент встроенным (стандартным компонентов HTML), или компонентом JSX. Встроенный компонент используется без изменений, тогда как JSX-компонент преобразовывается в JavaScript-код транспайлером.

### Полезные трюки в React

Выражения (**Expressions**) в JSX - мощный инструмент:

```jsx
const a = 1;
const b = 2;

const MyComponent = () =>
    <Box>Здесь используется выражение: {a + b}</Box>
```

В выражениях мы може использовать тернарный оператор, ветвление - вообще, что угодно:

```jsx
const MyComponent = () =>
    <Box>Выражение: {b > a ? "YES" : "NO"}</Box>
```

```jsx
const MyComponent = () =>
    <Box>Выражение: {
        const a = 1;
        const b = 2;

        if (a > b) {
            3
        }
    }</Box>
```

## Критика

Модель рендеринга React не обладает высокой вычислительной эффективностью. Основная причина состоит в:

- однопоточность (асинхронность помогает лишь отчасти)
- JavaScript, который работает в комбинированной модели исполнения байт-кода и нативного кода в режиме Just-In-Time Compilation

Стоит заметить, что при изменении состояния конмпонента перерисовывается только этот компонент (и дочерние), но для того, чтобы этот механизм работал эффективно необходимо спроектировать интерфейс таким образом, чтобы изменения не связанных компонентов не приводили к их ре-рендерингу. Также следует заметить, что оптимизация повторного рендеренга может быть достигнута при использовании мемоизации, хотя этот механизм не простой в использовании.

Вообще в случае использования React довольно много вещей приходится делать вручную, или посредством не очевидных конструкций. В частности:

- изменение состояния осуществляется вручную посредством вызова функции, возвращаемой useState()
- если необходимо изменить состояние основываясь на предыдущем состоянии, то необходимо использовать специальный синтаксис `setEditing(isEditing => !isEditing)`. Ошибочная конструкция: `setEditing(!isEditing)`

Рекомендуется просмотр видео [React мемоизация - useCallback, useMemo, memo](https://rutube.ru/video/4c3df952aa240c1a653a6884718bea82/) by "Позитивный подъем".

Рендеринг компонента - это выполнение JavaScript-кода, размещённого внутри этого компонента, включая JavaScript-код, который создаётся транспиляцией TSX в многоступенчатые вызовы React.createElement(). Например, при рендеринге/повторном рендеринге компонента EmployeeModal будут создаваться контексты выполнения для всех вызовов внутри функции EmployeeModal(). В случае использования состояний (useState()), создаваемые функции не будут сохраняться в области данных React, но создаваться они всё равно будут. Отчасти проблема может быть решена посредством мемоизации, но этот вид оптимизации необходимо выявлять вручную, вручную мемоизировать (React.memo(), useCallback()), а затем вручную проверять её эффективность.

Т.е. любая активность, связанная с пользовательским интерфейсом, будет приводить к расходу вычислительных ресурсов, часть которых будет расходоваться впустую, т.к. React будет отвергать сгенерированные функции.

Мы можем говорить о том, что действия, связанные с пользовательским интерфейсом инициируются "медленным" человеком, а ресурсов современного компьютера достаточно, чтобы спокойно отнестись к холостой работе процессора в кратковременные моменты времени, но вычислительные возможности компьютеров тоже бывают разными.

Так же следует обратить внимание, что React хранит VirtualDOM, состояния и ещё кучу всего в оперативной памяти, что приводит к её повышенному расходу. Это опять же, может быть не заметно на современных компьютерах, но существуют компьютеры, на которых недостаток памяти может приводить и к серьёзным проблемам с производительностью.

### Вероятно позитивный шаг - переход React к независимости

В статье [Introducing the React Foundation](https://react.dev/blog/2025/10/07/introducing-the-react-foundation) приводится информация о том, что React перестал быть внутренней разработкой Meta и перешёл в зону ответственности независимой организации **React Foundation**. Переход касается как React, так и React Native.

Спонсоры новой организации: Meta, Amazon, Microsoft и Vercel.

### Когда мемоизация действительно помогает

По результатам изучения статей на Medium.com, мемоизация помогает в следующих случаях:

- компонент действительно часто осуществлет Rendering
- Props стабильны, или примитивны
- Rendering обходится очень дорого (по метрикам)

В качестве метрик эксперты предлагают использовать FPS в Dashboard (60+ является отличным результатов) , а также Lighthouse Performance (значение должно быть 85+).

>В 2025 году представлен инструмент [React Compiler](https://react.dev/learn/react-compiler), который осуществляется автоматическую оптимизацию React-приложений, устраняя необходимость в ручном написании `useMemo`, `useCallback` и `React.memo`.

## Популярные UI библиотеки для React

Рекомендуется для ознакомления статья [Библиотеки UI-компонентов для React в 2025 году](https://habr.com/ru/companies/otus/articles/927846/) by _Luke Stahl_.

- [Material UI](https://mui.com/material-ui/)
- [Chakra UI](https://www.chakra-ui.com/). Работает с Next.js
- [Radix UI + Tailwind](https://www.radix-ui.com/)
- [Next UI](https://nextjs.org/) - оптимизация для Next.js
- [Ant Design](https://ant.design/) - хорош для корпоративных приложений, очень много компонентов
- [Mantine](https://v3.mantine.dev/) - встроенная система генерации и валидации форм
- [Shadcn UI](https://ui.shadcn.com/) - анимации
- [React Aria](https://react-spectrum.adobe.com/react-aria/index.html) от Adobe
- [Headless UI](https://headlessui.com/)
- [Base UI](https://base-ui.com/)
- [Builder.io](https://www.builder.io/)

## Компонентная модель, в целом - здорово

При разработке приложения на React крайне важно осуществлять авторский контроль и систематически заниматься улучшением кода.

В первом варианте приложения, список свойств модального диалога получился очень большим:

```tsx
<EmployeeModal 
    isOpen={isModalOpen}
    isEditMode={isEditMode}
    setModalShow={setModalShow}
    surnameField={surname} 
    setSurnameField={setSurname} 
    positionField={position} 
    setPositionField={setPosition}
    onSubmit={handleSubmit}
/>
```

А также определяются в дочерних компонентах:

```tsx
type ModalComponentProps = {
    isOpen: boolean;
    isEditMode: boolean;
    setModalShow: (state: boolean) => void;
    surnameField: string;
    setSurnameField: React.Dispatch<React.SetStateAction<string>>;
    positionField: string;
    setPositionField: React.Dispatch<React.SetStateAction<string>>;
    onSubmit: () => void;
};

const EmployeeModal: React.FC<ModalComponentProps> = ({ 
    isOpen, isEditMode, setModalShow, surnameField, setSurnameField, positionField, setPositionField, onSubmit,
}) => {
```

>React.FC<> это синоним React.FunctionComponent<>.

Однако потом было принято решение использовать отдельный тип для хранения состояния объекта "модальный диалог". Описание состояния было вынесено в отдельный файл - "types.ts":

```ts
export type EmployeeData = {
  surname: string;
  position: string;
};
```

И сам модальный диалог, и его родительский компонент импортируют этот тип:

```ts
import { EmployeeData } from './types';
```

В результате хранения состояния в виде объекта, позволило значительно сократить количество свойств модального диалога:

```ts
type EmployeeModalProps = {
    show: boolean;
    isEditMode: boolean;
    initialData?: EmployeeData;
    onClose: () => void;
    onSubmit: (data: EmployeeData) => void;
};
```

Важным изменение в коде также является делегирование решение о закрытии модального диалога родительскому компоненту, что позволяет, например, не закрывать модальное окно, если валидация данные завершилась не корректно.

## Вынос состояния в родительский компонент - OK, но не совсем

Состояния определяются в родительском окне и передаются через props в дочерние:

```ts
function App() {

    // Определяем состояние "активатор модального окна"
    const [isModalOpen, setModalShow] = useState(false);

    // Определяем режим работы модального окна
    const [isEditMode, setEditMode] = useState(false);

    // Определяем состояния полей для ввода ФИО и должности
    const [surname, setSurname] = useState<string>('');
    const [position, setPosition] = useState<string>('');
```

Это лишь отчасти напоминает шаблон проектирования MVVM. В MVVM есть ModelView, в котором находятся все необходимые атрибуты, разные Views могут использовать один общий ModelView и передавать каждому дочернему компоненты все необходимые ему свойства через props не нужно.

Подход React выглядит избыточным. Допускаю, что в сложных формах он может быть чрезвычайно избыточным.

>Решением проблемы с избыточностью является добавление в приложение _state management_. Главная задач state management в React и состоит в том, чтобы избежать длинных маршрутов доставки изменений. Шаблон проектирования Publish/Subscribe подходит для этого, практически, идеально.
>
>Однако негативным следствием введения в систему state management является усложнение кода и логики, а также необходимость выбора внешней библиотеки, соответствующей типу приложения.
>
>Заметим, что в Blazor сделана попытка избежать внедрения state management за счёт использования каскадирования параметров (CascadingParameter). Однако каскадирование работает для простых иерархических схем, а для сложных связей всё равно приходится вводить в систему state management.

## К "синтаксическому сахару" можно привыкнуть, но он не очевидный

Пример:

```tsx
<Modal.Title>
    {isEditMode === false && (
        <>Добавление нового сотрудника</>
    )}
    {isEditMode === true && (
        <>Редактирование сотрудника</>
    )}
</Modal.Title>
```

Привыкнуть можно, но выглядит это как китайский иероглиф, т.е. его придётся выучить, он не очевиден сам по себе.

## Вызов методов дочерних компонентов требует значительных усилий

Императивный стиль программирования React не любит, предпочитая декларативный. Однако в сложных приложениях избежать использования императивного стиля невозможно.

См.: forwardRef, useImperativeHandle, Ref.

Существуют компоненты, которые предоставляют API, а не только props. Хороший пример - таблица DataTables.NET.

Нужно определить экспортируемый тип, затем использовать useImperativeHandle(), чтобы _to expose_ функции родительскому элементу. Родитель также должен использовать useRef(), чтобы воспользоваться методами дочернего компонента.

## Что же в React есть хорошего?

React реализует компонентную модель и она работает. Но она медленная и работает со значимыми ограничениями.

TypeScript работает хорошо. AutoComplete в VSCode - надёжный, проверки типов Linter-ом даёт ложные срабатывания, но, в целом, работает.

Интеграция с Bootstrap 5 и DataTables.NET, на мой взгляд, на четыре с плюсом. Один плюсик потерян из-за того, что есть множество не очевидных моментов, которые приходится искать (иногда с большим трудом).

Несомненно, к хорошему можно отнести Plug-in для Chrome **React Developer Tools**, который позволяет просматривать структуру VirtualDOM, данные, которые хранит React, а также содержит Profiler, посредством которого можно оценивать, рендеринг какого из компоненентов занял больше всего времени в конкретный re-render. Создаётся впечатление, что DevTool действительно очень хороший, полезный инструмент.

## Оценка будущего React

В 2025 году, всё совсем не однозначно. Основная проблема инструмента - фрагментация. Ключевое направление развития React - SSR (Server-Side Rendering), решающий многие из проблем существующих React-приложений.

Три вещи, которые нужны для работы SSR:

- Bundler, который умеет разделять код на серверные и клиентские компоненты
- Server, который загружает js bundle, формирует контент и передаёт его клиентскому компоненту
- Client-Side Router, который умеет разделять трафик на клиентский и серверный

Проблема состоит в том, что React/SSR нарушает идеоматический способ разработки React-приложений. Более того, развитие различных React/SSR библиотек очень сильно ломает общую концепцию, библиотеки все более и более не совместимым друг с другом. Т.е. выбирая React в качестве основной платформы разработчики должны выбрать "традиционный React", или SSR, а потом ещё и угадать, какую с SSR-библиотек использовать. С учётом жёсткой конкуренции между разработчиками альтернативных библиотек, вероятность принятия правильного решения (LTS проекта на 10 лет) в этой "угадайке" не очень высокая.

При этом, тот факт, что React/SSR ориентируется на Node.js на стороне сервера - это сильный сдерживающий фактор, т.к. оставляет "за бортом" растущие эко-системы: Go lang, .NET Core, Rust, Java Next.

Дополнительно, есть существенное давление со стороны альтернативных разработок:

- Vue.js (на подъёме)
- Angular (падение, но пока не свободное)
- Svelte, Blazor (странная, леворезьбовая история)
- развитие экосистемы WASM

Из приведённых выше, наиболее опасным для React является развитие Vue.js

## Где закопаны основные потери в React

JSX трансформируется в JavaScript-код, который выглядит как:

```js
React.createElement('div', null, 
    [React.createElement(...), ...],
React.createElement(...)
)
```

Для отображения контента, React сначала формирует RenderTree, создавая элементы (они были определены в JSX) этого дерева, в затем выполняет полный проход по дереву, чтобы сформировать VirtualDOM.

Если при обработке событий изменяется состояние какого-то элемента (например, вызывается функция, который ранее вернул useState()), то снова строиться всё дерево, формируется новый RenderTree. Затем старый и новый VirtualDOM сравниваются, различия отражаются в DOM браузера.

Поскольку изменение DOM браузера очень медленное, обновление только отличий значительно улучшает производительность приложения.

Однако, приложению нужно значительно больше памяти (чтобы хранить последний VirtualDOM, а также данные React, включая состояния). Кроме этого, при каждом изменении создаётся новый RenderTree, который может быть просто огромного размера. Следует заметить, что вызов каждой функции JavaScript создаёт контекст вызова и всё это требует значимых вычислительных ресурсов.

Таким образом, основные потери React закопаны в:

- формировании RenderTree при изменении любого состояния приложения (см. useState)
- обходе всего RenderTree для формирования VirtualDOM
- сравнении предыдущего и нового VirtualDOM
- обновлении DOM браузера

С учётом того, что JavaScript однопоточный, улучшить отзывчивость системы, например, увеличив количество ядер процессора невозможно. Более того, частота процессора, на котором работает является критичной.

>Из вышесказанного можно сделать два дополнительных вывода:
>
>- работа React-приложений на процессорах в которых нет мощных P-ядер (хотя бы одного) - это потенциальная проблема
>- SSR отлично утилизирует многоядерность сервера, разгружая клиентские компьютеры

### Что думают разработчики о React

Развиваясь, React приложение создаёт безумный client-side state для доступа к серверу и тянет за собой безумое развитие server-side. И для того, чтобы бороться с этим безумием, React-разработчики мигрируют на React/SSR.

Однако, в 2025 году есть целая куча конкурирующих SSR-решения в эко-системе React и выбрать подходящий сложно. К сожалению, использование Node.js/TypeScript на сервере лишает разработчиков огромного количества удобств и классных инструментов, таких как LINQ и EF в .NET.

Рекомендуется для ознакомления обсуждение на [Reddit](https://www.reddit.com/r/Blazor/comments/17irng3/blazor_the_end_of_react/?rdt=42081)

### Мемоизация - способ снизить вычислительную нагрузку

Предположим, что у нас в JSX определена кнопка:

```jsx
const [counter, setCounter] = useState(0);
const increase = () => setCounter((s) => s + 1);

return(
    <div>
        <FancyButton onClick={increase}>
            Increase counter
        </FancyButton>
        <Counter value={counter} />
    </div>
);

const Counter = ({value}) => {
    return <div>{value}</div>;
};

const FancyButton = ({onClick, children}) => {
    return <button onClick={onClick}>{children}</button>;
};
```

Первое, что мы можем сделать - избежать создания новой функции setCounter() при каждом нажатии на FancyButton. Для этого мы можем добавить useCallback():

```jsx
const [counter, setCounter] = useState(0);
const increase = useCallback(() => setCounter((s) => s + 1), [setCounter]);
```

Вызов useCallback() сохранит функцию, указанную в первом параметре в React и при следующем вызове, вернёт её из React-а. Однако, при втором и последующих рендерах анониманая функция с `setCounter((s) => s + 1)` всё равно будет определена. После того, как она будет определена, она будет передана в React и React её отбросит, вернув самый первый вариант функции. Т.к. конкретно в данном случае, никакой реальной оптимизации не будет, т.к. функция всё равно будет определена, а затем проигнорирована React-ом. По сути, мы даже ухудшили производительность и увеличили размер памяти для хранения данных React.

Реальный смысл использования useCallback() есть при его совместном использовании с memo. Чтобы получить реальный выигрыщ, нам нужно мемоизировать FancyButton:

```jsx
const FancyButton = React.memo(({onClick, children}) => {
    return <button onClick={onClick}>{children}</button>;
});
```

Сделав так, мы указываем React-у, что кусочек RenderTree, генерируемый FancyButton должен создаваться по новой только в том случае, если у нас изменяется либо onClick, либо children.

И вот тут возникает **самый важный момент** в мемоизации: функция FancyButton не будет генерироваться снова если функция onClick и children не поменяются. И поскольку мы использовали useCallback() для мемоизации функции increase, React использует ранее сформированную FancyButton, а не новую. Совместное использование useCallback() и React.memo() позволит экономить время на повторном рендеринге FancyButton(), хотя функция `() => setCounter((s) => s + 1)` всё равно будет создаваться при каждом рендеринге. Жертвуя малым, мы экономим на большом.

### useMemo()

React.memo() позволяет нам избежать повторного создания функции. useMemo(), в свою очередь, ориентирован на сохранение не функции, а результата её работы.

Допустим, что у нас есть компонент, который генерируем список:

```ts
const UsersList = ({ users }) => {
    return <div>
            <List items={users} />
        </div>;
};

const List = React.memo(({items}) => {
    return items.map(({ id, value}) => <div key={id}>{value}</div>)
});
```

Допустим, мы хотим отображать данные из списка по некоторому условию. Наш код мог бы быть изменён следующим образом:

```ts
const UsersList = ({ users }) => {
    const visibleUsers = users.filter(({ visible }) => visible);
    return <div>
            <List items={visibleUsers} />
        </div>;
};
```

И в этом случае, React.memo() становится совершенно бесполезным, т.к. при каждом выполнении users.filter() мы будем получать новый вариант контейнера (хотя данные будут теми же самыми) и это будет приводить к тому, что при каждой смене состояния компонент UsersList будет полностью перерисовываться. Т.е. React.memo() вместо пользы, начнёт приносить вред, из-за лишнего вызова и расхода памяти в области React-а.

Чтобы у нас действительно появилось улучшение, нужно избегать того, чтобы каждый вызов users.filter() возвращал нам новый список. Для этого и используется useMemo():

```ts
const visibleUsers = useMemo (() => users.filter(({ visible }) => visible), [users]);
```

>Главный вывод: мемоизация - инструмент, который требует от разработчика очень хорошего понимания того, что происходит "под капотом", потому, что при неудачном использовании (которое очень вероятно), производительность приложение не будет улучшена, а скорее всего - сильно ухудшена.
>При выполнении code review следует смотреть на то, используются ли useMemo() и useCallback() без React.memo(). Если используются, что нужно очень
внимательно анализировать код компонента.
>
>Также критичным может быть создание стандартизированной структуры папок проекта и общих подходов к разработке решения. Например, при разработке формы - описание данных оформлять как тип в отдельном файле, с тем, чтобы иметь возможность использовать его и в родительском, и в дочернем компонентах. Если пустить разработку на самотёк, она очень быстро захламиться и её сопровождение будет критически усложнено.

## Способы упростить разработку на React

В статье [Быстрый Frontend в 2025: почему RTK Query, Tailwind и Vite убивают классические подходы](https://habr.com/ru/articles/918558/) рассматривается возможность использования RTK Query, Tailwind и Vite для ускорения разработки front-end на React.

Tailwind должен упростить работу с таблицами стилей.

RTK Query позволяет заменить разработки Action-ов/Reducer-ов (State Management) в случае использования Redux Thunk. Типовой код на Redux + Axios:

```js
const fetchPosts = () => async (dispatch) => {
    dispatch({ type: 'FETCH_POSTS_REQUEST' });

    try {
        const res = await axios.get('/api/posts');
        dispatch({ type: 'FETCH_POSTS_SUCCESS', payload: res.data });
    } catch (err) {
        dispatch({ type: 'FETCH_POSTS_FAILURE', error: err.message });
    }
};
```

Тоже самое "из коробки" от [RTK Query](https://redux-toolkit.js.org/rtk-query/overview) (Redux Toolkit):

```js
const { data, error, isLoading } = useGetPostsQuery();
```

Vite, как Package Manager гораздо более быстрый и менее сложный, чем WebPack.

## Терминология React

Определяются неконтролируемые компоненты и компоненты контролируе React.

Неконтролируемые компоненты (_uncontroller components_) - это элементы обычной HTML-верстки, например:

```jsx
const Form = () => {
    return (
        <form>
            <input type="text" />
            <button type="submit">Submit</button>
        </form>
    );
};
```

Пример контролируемого компонента (_controller component_):

```jsx
const Form = () => {
    const [value, setValue] = useState("");
    return (
        <form>
            <input type="text" 
                value={value} onChange={(e) =>
                    setValue(e.target.value)
                } />
            <button type="submit">Submit</button>
        </form>
    );
};
```

## Hook useContext

Контекст в React это способность передачи данных через дерево компонентов, минуя прокидывание данных через _props_ от одного компонента к другому.

До создания State Management (Redux и Mobx) данные передавались от самого верхнего компонента к нижним через props, иногда минуя огромные цепочки связанных компонентов. Этот подход избыточен и отличается низкой эффективностью. Для решения проблемы в React был введён **Context API**.

>Довольно часто Context используется для визуализации список с каким-то одним активным элементом: закладки (Tab-ы), меню, Accordion, и т.д. В этом случае родительский элемент группирует дочерние, а действия над дочерним элементом (click) влияет на все элементы группы. Т.е. можно говорить о том, что **Context** позволяет создавать групповое поведение для некоторой иерархиии компонентов, в которой изменение одного дочернего элемента затрагивает другие элементы.

Создать контекст можно используя функцию React.createContext(), которая имеет единственный параметр - значение по умолчанию, или объект для передачи дочерним компонентам через контекст. 

```js
const context = React.createContext('value');
```

Функция React.createContext() создаёт два компонента: провайдера и потребителя:

```js
<Сontext.Provider value={"value"}>
```

```js
<Context.Consumer>
   { value = > <div>value</div> }
</Context.Consumer>
```

Часто в приложении не хватает одного контекста, но React позволяет создавать несколько разных контекстов.

### Практический пример использования контекста

```js
const AccordionContext = createContext({
    activeItemIndex: 0,
    setActiveItemIndex: () => 0,
});
```

Результат вызова createContext() может быть использован в JSX-верстке, например:

```js
export const Accordion = ({items}) => {
    const [activeItemIndex, setActiveItemIndex] = useState(0);

    return (
        <AccordionContext.Provider value={{ activeItemIndex, setActiveItemIndex }}>
            <ul>{children}</ul>
        </AccordionContext.Provider>
    );
};
```

>Заметим, что **children** в React - это особенное зарезервированное свойство, которое содержит дочерние JSX-элементы.

В приведённом выше коде мы создали контекст, в котором определена переменная состояния и функция для изменения состояния.

Далее мы можем определить дочерний компонент, экземпляры которого будут использовать этот контекст для re-rendering-а. Заметим, что родительский компонент создал состояние (state), а дочерние элементы используют контекст.

Вот как может выглядеть дочерниий компонент:

```js
export const AccordionItem = ({item, index}) => {
    const { activeItemIndex, setActiveItemIndex } = useContext(AccordionContext);

    return (
        <li onClick={() => setActiveItemIndex(index)} key={item.id}>
            <strong>{item.label}</strong>
            {index === activeItemIndex && item.content}
        </li>
    );
}
```

В приведённом выше коде мы определяем элемент списка, который вызывает метод изменения контекста при щелчке на элемент, что приведёт к установке конкретного дочернего элемента в активное состояние, а так же, поскольку состояние контекста измениться, то выполнит ре-рендеринг родительского компонента.

Использовать компонент Accordion мы можем, например, таким образом:

```js
const items = [
    {label: "One", content: "lorem ipsum for more, see http://one.com"},
    {label: "Two", content: "lorem ipsum for more, see http://two.com"},
    {label: "Threee", content: "lorem ipsum for more, see http://three.com"},
];

<Accordion>
    {items.map((item, index) => (
        <AccordionItem key={item.id} item={item} index={index} />
    ))} 
</Accordion>
```

Чем хорош данный подход: рендерингом управляем родительский элемент, тогда как дочерние элементы имеют информацию о текущем состоянии родительского элемента.

Заметим также, что контекст доступен для вложенных на большую глубину элементов, а верстка может содержать различные дополнительные элементы, такие, например, как разделительная линия элементов.

По всей видимости, близким "родственником" в Blazor является _CascadingParameter_.


## Шаблон проектирования - разделение на презентационный и контейнерный компоненты

Рекомендуется разделять код, в котором есть верстка и получение данных через API на два компонента, с разными зонами ответсвенностями:

```js
// Компонент отвечает за представление данных (Presentation)
function UserList({ users }) {
    return (
        <ul>
        {users.map(user => <li key={user.id}>{user.name}</li>)}
        </ul>
    )
}

// Компонент отвечает за получение данных через API
function UserListContainer() {
    const [users, setUsers] = React,useState([]);

    React.useEffect(() => {
        fetch('/api/users')
            .then(res => res.json())
            .then(data => setUsers(data));
    }, []);

    return <UserList users={users} />;
}
```

## Шаблон проектирования - использование Custom Hooks

Чтобы уменьшить дублирование кода, некоторые типовые действия, например, загрузку JSON с сайта, рекомендуется оформлять как отдельный пользовательский hook. Например:

```js
// Компонент осуществляет загрузку данных через API. Это пользовательский Hook
function useFetch(url) {
    const [data, setData] = React.useState(null);

    React.useEffect(() => {
        fetch(url)
            .then(res => res.json())
            .then(setData);
    }, [url]);

    return data;
}

// Компонент загружает данные через пользовательский Hook и формирует верстку
function Profile() {
    const user = useFetch('/api/user');

    if (!user) return <p>Loading...</p>;
    return <h1>{user.name}</h1>;
}
```

## Загрузка картинок

Поскольку React выполняет _bundling_ компонентов, включая изображения, необходимо использовать относительный путь к картинкам в приложении. Например:

```js
import React from 'react';
import logoImage from '../assets/logo.png'; // Относительный путь к изображению

const MyComponent: React.FC = () => {
  return (
    <div>
      <img 
        src={logoImage} 
        alt="Company Logo" 
        className="logo" 
      />
    </div>
  );
};

export default MyComponent;
```

## Синтаксический сахар при передаче props

Предположим, что у нас есть массив объектов, в которых хранятся повторяющаяся информация: картинка (image), заголовок (title), текстовое описание (description). Мы можем передавать в компонент объект целиком. В верстке это может выглядеть следующим образом:

```js
<CoreConcept {...CORE_CONCEPT[0]} />
```

В приведённом выше примере CORE_CONCEPT является массивом объектов и все элементы этого объекта будут переданы в компонент в виде отдельных свойств (_props_). Это возможно благодаря использованию _spread/rest operator_.

При определении компонента мы можем использовать _destructuring_ для излечения этих props по имени, например:

```js
function CoreConcept({image, title, description}) {  

}
```

## Обработка событий в JSX

Примеры вызова обработчиков событий при нажатии на экранную кнопку:

```tsx
import React, { useState } from 'react';

function ButtonExample() {
  const [count, setCount] = useState(0);

  const handleClick = () => {
    setCount(count + 1);
    console.log('Button was clicked!');
  };

  const handleSpecificClick = (message) => {
    alert(message);
  };

  return (
    <div>
      <button onClick={handleClick}>
        Clicked {count} times
      </button>

      <button onClick={() => handleSpecificClick('Hello, World!')}>
        Click me with a message
      </button>

      <button onClick={(e) => {
        console.log('Inline click handler');
        console.log('Event object:', e);
      }}>
        Inline Handler
      </button>
    </div>
  );
}

export default ButtonExample;
```

В типовой ситуации мы просто передаём через атрибут JSX-объекта указатель на функцию: `<button onClick={handleClick}>`. Важно помнить о том, что внутри фигурных скобок мы указываем JavaScript-код. Если мы указываем `handleClick`, то эта синтаксическая конструкция возвращает указатель на функцию, а если указываем `handleClick()` (и это синтаксически корректно), то возвращаем результат вызова функции **handleClick**().

Если при возникновении события нам нужно передать какую-то информацию в обработчик события, то в типовом случае следует использовать анонимную функцию:

```tsx
<button onClick={() => handleSpecificClick('Hello, World!')}>
```

## Conditional Rendering

В React используются типовые трюки для осуществления условного rendering-а. Наиболее простой вариант состоит в использовании тернатного оператора совместно с JSX, например:

```tsx
{selectedTopic ? (<p>Выбран: {selectedTopic}</p>) : (<p>Раздел не выбран</p>)}
```

Однако чаще встречается конструкция с использованием логического оператора &&:

```tsx
{selectedTopic && (<p>Выбран: {selectedTopic}</p>))}
```

Смысл конструкция в том, что если selectedTopic будет равен null, или undefined, то в соответствии с правилами использования логического "И", следующее "условие" проверяться уже не будет, т.к. условие уже лживое (false). Но если условие правдивое (true), то statement, следующий за && будет выполнен. И здесь срабатывает трюк транспайлера JSX, который для "вычисления условия" выполнит последовательность, которая, в свою очередь, добавит в верстку необходимые элементы. Так происходит потому, что JSX транслируется в последовательность функций, которые вполне могут быть использованы в логической цепочке, т.е. синтаксически конструкция является правильной, хотя она не проверяет условие, а участвует в генерации верстки.

## Использование map()

JSX может быть использован в массивах, например:

```tsx
{[<p>Hello</p>, <p>World</p>]}
```

В React очень часто встречается следующий код:

```tsx
return (
    <>
    {EXTERNAL_ARRAY.map((item) => (
        <CustomControl key={index} {...item} />
    ))}
    </>
);
```

Атрибут key необходим React-у для того, чтобы корректно осуществлять управление rendering-ом. Мы должны устанавливать этот атрибут в любое уникальное значение.

## Что такое Fragment в React

Компонент React возвращает только один React-элемент. Однако, мы можем включить любое количество дочерних элементов в этот компонент верхнего уровня.

Пример кода React-компоненты, в котором не используется JSX:

```tsx
import React from 'react';

interface UserProfileProps {
  name: string;
  age: number;
}

const UserProfile: React.FC<UserProfileProps> = ({ name, age }) => {
  return React.createElement(
    'div', 
    { className: 'user-profile' }, 
    React.createElement('h1', null, `Name: ${name}`),
    React.createElement('p', null, `Age: ${age}`),
    React.createElement(
      'button', 
      { onClick: () => console.log('Button clicked') }, 
      'Click me'
    )
  );
};

export default UserProfile;
```

Если разрабатываемый компонент должен вернуть несколько элементов на одном уровне, нам (гипотетически) необходимо упаковать его в родительский элемент. И на первый взгляд, кажется что логично обернуть элементы в div. В действительности, такое решение не очень хорошее, потому, что такой div на верхнем уровне будет перенесён в DOM и создаст дополнительный уровень вложенности, что создаёт избыточность. 

Разработчики React придумали специальный тип компонентов - Fragment, который может использоваться в разметке, но при транспиляции кода из JSX в JavaScript/TypeScript, он не будет включён в DOM. Т.е. по сути, это обёртка для того, чтобы обойти некоторое ограничение React.

В новых версиях React, Fragment был заменён на синтаксический сахар `<>...</>`, что делает код ещё более понятным и прямолинейным.

Однако про концепцию Fragment нужно знать, т.к. существует огромное количество унаследованного кода, в котором Fragment-компоненты активно используются.

## Refs & Portals

Иногда, даже простые действия в React могут требовать большого количества состояний (States). Предположим, что нам нужно отобразить на экране поле для ввода имени пользователя и кнопку Submit. В типовом решении, нам потребуется добавить состояния "имя пользователя" и "был-ли выполнен submit":

```js
const [enteredPlayerName, setEnteredPlayerName] = useState(null);
const [submitted, setSubmitted] = useSate(false);
```

Кажется, что в коде слишком много лишнего кода. Решить эту проблему можно используя Refs.

Определить Refs можно используя специальный hook - useRef:

```js
import { useState, useRef } from 'react';

export default function Player() {
    const playerName = useRef();
```

```js
<input ref={playerName} type="text" onChange={handleChange} value={enteredPlayerName} />
```

Ref - это переменная, которая хранит ссылку на конкретный JSX-элемент в верстке. Сначала мы должны создать ссылку в JavaScript/TypeScript-коде, а затем проинициализировать её в описании JSX-компонента. После этого мы можем использовать эту ссылку для изменения JSX-элемента. Например:

```js
function handleClick() {
    setEnteredPlayerName(playerName.current.value);
}
```

Следует заметить, что `current` - это реальная ссылка на DOM-элемент. В приведённом выше примере мы можем напрямую изменять конкретное состояние формы, за счёт ручного управления, убрать часть избыточных состояний (в привере выше - мы можем избавиться от submitted).

Ref очень удобен для ручного управления JSX/DOM-элементов. И конечно же мы может не только изменять состояния формы, но и напрямую влиять на DOM-элементы. Например мы можем сбросить состояние строки ввода следующим образом:

```js
playerName.current.value = '';
```

Однако следует заметить, что основная парадигма React - описание задачи в декларативном стиле, а не ручное управление DOM, т.е. в определённом смысле, Refs нарушает "чистоту React". Именно в этом и состоит основная проблем Refs - он смешивает императивный и декларативный стили программирования в приложении.

