# Заметки об использовании React

Начать нужно с того, что делает React (или Blazor, или другой инструмент, реализующий **декларативное программирование**, в отличие от **императивного** при использовании Vanilla JavaScript), по сути, безальтернативным при разработке web-приложений.

Ключевым для обеспечения качества работы приложения является его умение контролировать изменение состояния. В случае, если мы используем Vanilla JavaScript, изменение состояния носит хаотичный характер. Управление добавлением, или удалением элементов, подписок, и т.д., крайне сложно надёжно реализовать вручную.

Обычно, код написанный на Vanilla JavaScript является очень хрупким. Основные проблемы:

- **Unsafe**: обработчик некоторого события (например, нажатия на кнопку) может быть легко переопределён другим JavaScript-кодов на странице. Чтобы избежать этого мы можем использовать addEventListener, но в этом случае мы должны аккуратно вызывать removeEventListener, чтобы избежать утечки ресурсов и замедления работы приложения
- **Unpredicatable**: в случае большого объёма верстки можно легко ошибиться в написании идентификатора и, в частности, получить коллизию имён элементов DOM, которая может быть обнаружена в очень редких случаях
- **Inefficient**: операция изменения DOM (_mutation_) является очень дорогой и кажется важным накапливать изменения и осуществлять их одной большой операцией, а не множеством мелких операций

React решает приведённые выше проблемы, добавляя к этому возможности применения императивного программирования. Преимущество подхода состоит в том, что используя JSX (Javascript Syntax eXtension) мы описывам то, что мы хотем увидеть, а не то, как мы достигаем результата.

>Для всех файлов с расширениями ".jsx" и ".tsx" применяется JSX-транспайлер, который применяет токенайзер (lexer) для выделения отдельных токенов в файле, затем осуществляет парсинг выполняя построение **синтаксического дерева**, которое можно представить в виде JSON-документа. На следующем этапе, осуществляется генерация JavaScript-кода, соответствующего содержимому синтаксического дерева.
>
>Таким образом мы переходим от конструкции `(<Box prop="value">Ящик</Box>)` к JavaScript-коду `React.createElement(Box, {prop: "value"}, "contents");`.
>
>Здесь возникают следующие потери:
>
>- транспиляция требует времени и цепочка транспиляции может быть большой (TSX -> TypeScript, TypeScript -> JavaScript)
>- трансляция JavaScript в браузере, может значительно влиять на время запуска приложения

Ключевые техники оптимизации React-приложений связаны с уменьшением количества re-rendering-а, что достигается уменьшением количества изменений состояния функциональных компонентов. Чаще всего применяются: мемоизация (определение неизменяемых компонентов и элементов верстки), применением вычисляемых "состояний", а также производных (derived) "состояний". Последние два пункта не являются состояниями, а имитируют их, используя другие реальные состояния в системе.

>Существует граница между React до 19 версии и React 19 и выше. До версии 19, для обеспечения высокой скорости работы приложения требовалось выполнять профилирование кода и оптимизировать его, преимущественно, используя мемоизацию. Если этого не делать, то в работающем приложении возникает огромное количество неуправляемых re-rendering-ов, которые приводят к ухудшению пользовательского опыта из-за задержек в работе пользовательского интерфейса. Начиная с React 19 Meta используют React Compiler и посредством статического анализа кода автоматически  применяя мемоизацию там, где это безопасно.
>
>Однако компилятор опционален и для его использования необходимо его установить и настроить в системе сборке, а для корректной работы также необходимо соблюдать т.н. "Правила React".

>Rayn Carniato (разработчик Solid.js и инструментов Reactivity для web-framework-ов) в свойм выступлении "JavaScript Frameworks - Heading into 2026": польза от React Compiler не так однозначна, как кажется. Компилятор может довольно эффективно создавать мемоизацию, но код, который получается в результате "компиляции" не читаемый и его нельзя использовать для отладки. Таким образом, мы получили очередной "magic": если работает, то это магия, а если не работает, то это неисправимая чёрная магия.
>
>Другие замечания:
>
>- в 2026 году выбор Web Framework-а уже не имеет значения. Основная причина - AI, который нивелирует возникающие benefit-ы от использования конкретных инструментов, предлагая разработчикам: _deprecated dependencies_, _useEffect hooks_, _state management "anti-patterns"_. Можно даже получить _class component_ из прошлого века
>- React имеет целый ряд проблем: _accidental re-rendres_, _hydration bugs_, _suspense waterfalls_. Сильная привязка к Virtual DOM - это _architectural overhead_.
>- Server Components плох для: _real interaction_, _long-lived client state_, _complex user flaws_
>- Remix: избавлятся от зависимостей конкретных Frameworks
>
>В будущем нас ждут новые технологические подходы:
>
>- Out-of-Order streaming - Framework не ждёт всех данных для того, чтобы начать отрисовывать пользовательский интерфейс
>- Server Functions - ?
>- Granular Optimistic UI - если изменилось что-то в маленьком компоненте, то обновляется только он. Другие компоненты не затрагиваются
>- Single-Flight mutations - система автоматически устраняет дубликаты сообщений, которые изменяют (mutate) состояние приложения
>
>**Isomorphic JavaScript**: The Future of Web Apps. Frontend и Backend будут заменены на Application Framework, который позволяет разрабатывать приложение не специализируясь на Frontend, или Backend. Идея изначально была реализована в Meteor в 2012 году.

### Почему Custom Components начинаются с заглавной буквы

React смотрит на регистр первой буквы в имени компонент и принимает решение о том, является ли компонент встроенным (стандартным компонентов HTML), или компонентом JSX. Встроенный компонент используется без изменений, тогда как JSX-компонент преобразовывается в JavaScript-код транспайлером.

### Полезные трюки в React

Выражения (**Expressions**) в JSX - мощный инструмент:

```jsx
const a = 1;
const b = 2;

const MyComponent = () =>
    <Box>Здесь используется выражение: {a + b}</Box>
```

В выражениях мы може использовать тернарный оператор, ветвление - вообще, что угодно:

```jsx
const MyComponent = () =>
    <Box>Выражение: {b > a ? "YES" : "NO"}</Box>
```

```jsx
const MyComponent = () =>
    <Box>Выражение: {
        const a = 1;
        const b = 2;

        if (a > b) {
            3
        }
    }</Box>
```

## Критика

Модель рендеринга React не обладает высокой вычислительной эффективностью. Основная причина состоит в:

- однопоточность (асинхронность помогает лишь отчасти)
- JavaScript, который работает в комбинированной модели исполнения байт-кода и нативного кода в режиме Just-In-Time Compilation

Стоит заметить, что при изменении состояния конмпонента перерисовывается только этот компонент (и дочерние), но для того, чтобы этот механизм работал эффективно необходимо спроектировать интерфейс таким образом, чтобы изменения не связанных компонентов не приводили к их ре-рендерингу. Также следует заметить, что оптимизация повторного рендеренга может быть достигнута при использовании мемоизации, хотя этот механизм не простой в использовании.

Вообще в случае использования React довольно много вещей приходится делать вручную, или посредством не очевидных конструкций. В частности:

- изменение состояния осуществляется вручную посредством вызова функции, возвращаемой useState()
- если необходимо изменить состояние основываясь на предыдущем состоянии, то необходимо использовать специальный синтаксис `setEditing(isEditing => !isEditing)`. Ошибочная конструкция: `setEditing(!isEditing)`

Рекомендуется просмотр видео [React мемоизация - useCallback, useMemo, memo](https://rutube.ru/video/4c3df952aa240c1a653a6884718bea82/) by "Позитивный подъем".

Рендеринг компонента - это выполнение JavaScript-кода, размещённого внутри этого компонента, включая JavaScript-код, который создаётся транспиляцией TSX в многоступенчатые вызовы React.createElement(). Например, при рендеринге/повторном рендеринге компонента EmployeeModal будут создаваться контексты выполнения для всех вызовов внутри функции EmployeeModal(). В случае использования состояний (useState()), создаваемые функции не будут сохраняться в области данных React, но создаваться они всё равно будут. Отчасти проблема может быть решена посредством мемоизации, но этот вид оптимизации необходимо выявлять вручную, вручную мемоизировать (React.memo(), useCallback()), а затем вручную проверять её эффективность.

Т.е. любая активность, связанная с пользовательским интерфейсом, будет приводить к расходу вычислительных ресурсов, часть которых будет расходоваться впустую, т.к. React будет отвергать сгенерированные функции.

Мы можем говорить о том, что действия, связанные с пользовательским интерфейсом инициируются "медленным" человеком, а ресурсов современного компьютера достаточно, чтобы спокойно отнестись к холостой работе процессора в кратковременные моменты времени, но вычислительные возможности компьютеров тоже бывают разными.

Так же следует обратить внимание, что React хранит VirtualDOM, состояния и ещё кучу всего в оперативной памяти, что приводит к её повышенному расходу. Это опять же, может быть не заметно на современных компьютерах, но существуют компьютеры, на которых недостаток памяти может приводить и к серьёзным проблемам с производительностью.

### Вероятно позитивный шаг - переход React к независимости

В статье [Introducing the React Foundation](https://react.dev/blog/2025/10/07/introducing-the-react-foundation) приводится информация о том, что React перестал быть внутренней разработкой Meta и перешёл в зону ответственности независимой организации **React Foundation**. Переход касается как React, так и React Native.

Спонсоры новой организации: Meta, Amazon, Microsoft и Vercel.

### Когда мемоизация действительно помогает

По результатам изучения статей на Medium.com, мемоизация помогает в следующих случаях:

- компонент действительно часто осуществлет Rendering
- Props стабильны, или примитивны
- Rendering обходится очень дорого (по метрикам)

В качестве метрик эксперты предлагают использовать FPS в Dashboard (60+ является отличным результатов) , а также Lighthouse Performance (значение должно быть 85+).

>В 2025 году представлен инструмент [React Compiler](https://react.dev/learn/react-compiler), который осуществляется автоматическую оптимизацию React-приложений, устраняя необходимость в ручном написании `useMemo`, `useCallback` и `React.memo`.

## Популярные UI библиотеки для React

Рекомендуется для ознакомления статья [Библиотеки UI-компонентов для React в 2025 году](https://habr.com/ru/companies/otus/articles/927846/) by _Luke Stahl_.

- [Material UI](https://mui.com/material-ui/)
- [Chakra UI](https://www.chakra-ui.com/). Работает с Next.js
- [Radix UI + Tailwind](https://www.radix-ui.com/)
- [Next UI](https://nextjs.org/) - оптимизация для Next.js
- [Ant Design](https://ant.design/) - хорош для корпоративных приложений, очень много компонентов
- [Mantine](https://v3.mantine.dev/) - встроенная система генерации и валидации форм
- [Shadcn UI](https://ui.shadcn.com/) - анимации
- [React Aria](https://react-spectrum.adobe.com/react-aria/index.html) от Adobe
- [Headless UI](https://headlessui.com/)
- [Base UI](https://base-ui.com/)
- [Builder.io](https://www.builder.io/)

## Компонентная модель, в целом - здорово

При разработке приложения на React крайне важно осуществлять авторский контроль и систематически заниматься улучшением кода.

В первом варианте приложения, список свойств модального диалога получился очень большим:

```tsx
<EmployeeModal 
    isOpen={isModalOpen}
    isEditMode={isEditMode}
    setModalShow={setModalShow}
    surnameField={surname} 
    setSurnameField={setSurname} 
    positionField={position} 
    setPositionField={setPosition}
    onSubmit={handleSubmit}
/>
```

А также определяются в дочерних компонентах:

```tsx
type ModalComponentProps = {
    isOpen: boolean;
    isEditMode: boolean;
    setModalShow: (state: boolean) => void;
    surnameField: string;
    setSurnameField: React.Dispatch<React.SetStateAction<string>>;
    positionField: string;
    setPositionField: React.Dispatch<React.SetStateAction<string>>;
    onSubmit: () => void;
};

const EmployeeModal: React.FC<ModalComponentProps> = ({ 
    isOpen, isEditMode, setModalShow, surnameField, setSurnameField, positionField, setPositionField, onSubmit,
}) => {
```

>React.FC<> это синоним React.FunctionComponent<>.

Однако потом было принято решение использовать отдельный тип для хранения состояния объекта "модальный диалог". Описание состояния было вынесено в отдельный файл - "types.ts":

```ts
export type EmployeeData = {
  surname: string;
  position: string;
};
```

И сам модальный диалог, и его родительский компонент импортируют этот тип:

```ts
import { EmployeeData } from './types';
```

В результате хранения состояния в виде объекта, позволило значительно сократить количество свойств модального диалога:

```ts
type EmployeeModalProps = {
    show: boolean;
    isEditMode: boolean;
    initialData?: EmployeeData;
    onClose: () => void;
    onSubmit: (data: EmployeeData) => void;
};
```

Важным изменение в коде также является делегирование решение о закрытии модального диалога родительскому компоненту, что позволяет, например, не закрывать модальное окно, если валидация данные завершилась не корректно.

## Вынос состояния в родительский компонент - OK, но не совсем

Состояния определяются в родительском окне и передаются через props в дочерние:

```ts
function App() {

    // Определяем состояние "активатор модального окна"
    const [isModalOpen, setModalShow] = useState(false);

    // Определяем режим работы модального окна
    const [isEditMode, setEditMode] = useState(false);

    // Определяем состояния полей для ввода ФИО и должности
    const [surname, setSurname] = useState<string>('');
    const [position, setPosition] = useState<string>('');
```

Это лишь отчасти напоминает шаблон проектирования MVVM. В MVVM есть ModelView, в котором находятся все необходимые атрибуты, разные Views могут использовать один общий ModelView и передавать каждому дочернему компоненты все необходимые ему свойства через props не нужно.

Подход React выглядит избыточным. Допускаю, что в сложных формах он может быть чрезвычайно избыточным.

>Решением проблемы с избыточностью является добавление в приложение _state management_. Главная задач state management в React и состоит в том, чтобы избежать длинных маршрутов доставки изменений. Шаблон проектирования Publish/Subscribe подходит для этого, практически, идеально.
>
>Однако негативным следствием введения в систему state management является усложнение кода и логики, а также необходимость выбора внешней библиотеки, соответствующей типу приложения.
>
>Заметим, что в Blazor сделана попытка избежать внедрения state management за счёт использования каскадирования параметров (CascadingParameter). Однако каскадирование работает для простых иерархических схем, а для сложных связей всё равно приходится вводить в систему state management.

## К "синтаксическому сахару" можно привыкнуть, но он не очевидный

Пример:

```tsx
<Modal.Title>
    {isEditMode === false && (
        <>Добавление нового сотрудника</>
    )}
    {isEditMode === true && (
        <>Редактирование сотрудника</>
    )}
</Modal.Title>
```

Привыкнуть можно, но выглядит это как китайский иероглиф, т.е. его придётся выучить, он не очевиден сам по себе.

## Вызов методов дочерних компонентов требует значительных усилий

Императивный стиль программирования React не любит, предпочитая декларативный. Однако в сложных приложениях избежать использования императивного стиля невозможно.

См.: forwardRef, useImperativeHandle, Ref.

Существуют компоненты, которые предоставляют API, а не только props. Хороший пример - таблица DataTables.NET.

Нужно определить экспортируемый тип, затем использовать useImperativeHandle(), чтобы _to expose_ функции родительскому элементу. Родитель также должен использовать useRef(), чтобы воспользоваться методами дочернего компонента.

## Что же в React есть хорошего?

React реализует компонентную модель и она работает. Но она медленная и работает со значимыми ограничениями.

TypeScript работает хорошо. AutoComplete в VSCode - надёжный, проверки типов Linter-ом даёт ложные срабатывания, но, в целом, работает.

Интеграция с Bootstrap 5 и DataTables.NET, на мой взгляд, на четыре с плюсом. Один плюсик потерян из-за того, что есть множество не очевидных моментов, которые приходится искать (иногда с большим трудом).

Несомненно, к хорошему можно отнести Plug-in для Chrome **React Developer Tools**, который позволяет просматривать структуру VirtualDOM, данные, которые хранит React, а также содержит Profiler, посредством которого можно оценивать, рендеринг какого из компоненентов занял больше всего времени в конкретный re-render. Создаётся впечатление, что DevTool действительно очень хороший, полезный инструмент.

## Оценка будущего React

В 2025 году, всё совсем не однозначно. Основная проблема инструмента - фрагментация. Ключевое направление развития React - SSR (Server-Side Rendering), решающий многие из проблем существующих React-приложений.

Три вещи, которые нужны для работы SSR:

- Bundler, который умеет разделять код на серверные и клиентские компоненты
- Server, который загружает js bundle, формирует контент и передаёт его клиентскому компоненту
- Client-Side Router, который умеет разделять трафик на клиентский и серверный

Проблема состоит в том, что React/SSR нарушает идеоматический способ разработки React-приложений. Более того, развитие различных React/SSR библиотек очень сильно ломает общую концепцию, библиотеки все более и более не совместимым друг с другом. Т.е. выбирая React в качестве основной платформы разработчики должны выбрать "традиционный React", или SSR, а потом ещё и угадать, какую с SSR-библиотек использовать. С учётом жёсткой конкуренции между разработчиками альтернативных библиотек, вероятность принятия правильного решения (LTS проекта на 10 лет) в этой "угадайке" не очень высокая.

При этом, тот факт, что React/SSR ориентируется на Node.js на стороне сервера - это сильный сдерживающий фактор, т.к. оставляет "за бортом" растущие эко-системы: Go lang, .NET Core, Rust, Java Next.

Дополнительно, есть существенное давление со стороны альтернативных разработок:

- Vue.js (на подъёме)
- Angular (падение, но пока не свободное)
- Svelte, Blazor (странная, леворезьбовая история)
- развитие экосистемы WASM

Из приведённых выше, наиболее опасным для React является развитие Vue.js

## Где закопаны основные потери в React

JSX трансформируется в JavaScript-код, который выглядит как:

```js
React.createElement('div', null, 
    [React.createElement(...), ...],
React.createElement(...)
)
```

Для отображения контента, React сначала формирует RenderTree, создавая элементы (они были определены в JSX) этого дерева, в затем выполняет полный проход по дереву, чтобы сформировать VirtualDOM.

Если при обработке событий изменяется состояние какого-то элемента (например, вызывается функция, который ранее вернул useState()), то снова строиться всё дерево, формируется новый RenderTree. Затем старый и новый VirtualDOM сравниваются, различия отражаются в DOM браузера.

Поскольку изменение DOM браузера очень медленное, обновление только отличий значительно улучшает производительность приложения.

Однако, приложению нужно значительно больше памяти (чтобы хранить последний VirtualDOM, а также данные React, включая состояния). Кроме этого, при каждом изменении создаётся новый RenderTree, который может быть просто огромного размера. Следует заметить, что вызов каждой функции JavaScript создаёт контекст вызова и всё это требует значимых вычислительных ресурсов.

Таким образом, основные потери React закопаны в:

- формировании RenderTree при изменении любого состояния приложения (см. useState)
- обходе всего RenderTree для формирования VirtualDOM
- сравнении предыдущего и нового VirtualDOM
- обновлении DOM браузера

С учётом того, что JavaScript однопоточный, улучшить отзывчивость системы, например, увеличив количество ядер процессора невозможно. Более того, частота процессора, на котором работает является критичной.

>Из вышесказанного можно сделать два дополнительных вывода:
>
>- работа React-приложений на процессорах в которых нет мощных P-ядер (хотя бы одного) - это потенциальная проблема
>- SSR отлично утилизирует многоядерность сервера, разгружая клиентские компьютеры

### Что думают разработчики о React

Развиваясь, React приложение создаёт безумный client-side state для доступа к серверу и тянет за собой безумое развитие server-side. И для того, чтобы бороться с этим безумием, React-разработчики мигрируют на React/SSR.

Однако, в 2025 году есть целая куча конкурирующих SSR-решения в эко-системе React и выбрать подходящий сложно. К сожалению, использование Node.js/TypeScript на сервере лишает разработчиков огромного количества удобств и классных инструментов, таких как LINQ и EF в .NET.

Рекомендуется для ознакомления обсуждение на [Reddit](https://www.reddit.com/r/Blazor/comments/17irng3/blazor_the_end_of_react/?rdt=42081)

### Мемоизация - способ снизить вычислительную нагрузку

Предположим, что у нас в JSX определена кнопка:

```jsx
const [counter, setCounter] = useState(0);
const increase = () => setCounter((s) => s + 1);

return(
    <div>
        <FancyButton onClick={increase}>
            Increase counter
        </FancyButton>
        <Counter value={counter} />
    </div>
);

const Counter = ({value}) => {
    return <div>{value}</div>;
};

const FancyButton = ({onClick, children}) => {
    return <button onClick={onClick}>{children}</button>;
};
```

Первое, что мы можем сделать - избежать создания новой функции setCounter() при каждом нажатии на FancyButton. Для этого мы можем добавить useCallback():

```jsx
const [counter, setCounter] = useState(0);
const increase = useCallback(() => setCounter((s) => s + 1), [setCounter]);
```

Вызов useCallback() сохранит функцию, указанную в первом параметре в React и при следующем вызове, вернёт её из React-а. Однако, при втором и последующих рендерах анониманая функция с `setCounter((s) => s + 1)` всё равно будет определена. После того, как она будет определена, она будет передана в React и React её отбросит, вернув самый первый вариант функции. Т.к. конкретно в данном случае, никакой реальной оптимизации не будет, т.к. функция всё равно будет определена, а затем проигнорирована React-ом. По сути, мы даже ухудшили производительность и увеличили размер памяти для хранения данных React.

Реальный смысл использования useCallback() есть при его совместном использовании с memo. Чтобы получить реальный выигрыщ, нам нужно мемоизировать FancyButton:

```jsx
const FancyButton = React.memo(({onClick, children}) => {
    return <button onClick={onClick}>{children}</button>;
});
```

Сделав так, мы указываем React-у, что кусочек RenderTree, генерируемый FancyButton должен создаваться по новой только в том случае, если у нас изменяется либо onClick, либо children.

И вот тут возникает **самый важный момент** в мемоизации: функция FancyButton не будет генерироваться снова если функция onClick и children не поменяются. И поскольку мы использовали useCallback() для мемоизации функции increase, React использует ранее сформированную FancyButton, а не новую. Совместное использование useCallback() и React.memo() позволит экономить время на повторном рендеринге FancyButton(), хотя функция `() => setCounter((s) => s + 1)` всё равно будет создаваться при каждом рендеринге. Жертвуя малым, мы экономим на большом.

### useMemo()

React.memo() позволяет нам избежать повторного создания функции. useMemo(), в свою очередь, ориентирован на сохранение не функции, а результата её работы.

Допустим, что у нас есть компонент, который генерируем список:

```ts
const UsersList = ({ users }) => {
    return <div>
            <List items={users} />
        </div>;
};

const List = React.memo(({items}) => {
    return items.map(({ id, value}) => <div key={id}>{value}</div>)
});
```

Допустим, мы хотим отображать данные из списка по некоторому условию. Наш код мог бы быть изменён следующим образом:

```ts
const UsersList = ({ users }) => {
    const visibleUsers = users.filter(({ visible }) => visible);
    return <div>
            <List items={visibleUsers} />
        </div>;
};
```

И в этом случае, React.memo() становится совершенно бесполезным, т.к. при каждом выполнении users.filter() мы будем получать новый вариант контейнера (хотя данные будут теми же самыми) и это будет приводить к тому, что при каждой смене состояния компонент UsersList будет полностью перерисовываться. Т.е. React.memo() вместо пользы, начнёт приносить вред, из-за лишнего вызова и расхода памяти в области React-а.

Чтобы у нас действительно появилось улучшение, нужно избегать того, чтобы каждый вызов users.filter() возвращал нам новый список. Для этого и используется useMemo():

```ts
const visibleUsers = useMemo (() => users.filter(({ visible }) => visible), [users]);
```

>Главный вывод: мемоизация - инструмент, который требует от разработчика очень хорошего понимания того, что происходит "под капотом", потому, что при неудачном использовании (которое очень вероятно), производительность приложение не будет улучшена, а скорее всего - сильно ухудшена.
>При выполнении code review следует смотреть на то, используются ли useMemo() и useCallback() без React.memo(). Если используются, что нужно очень
внимательно анализировать код компонента.
>
>Также критичным может быть создание стандартизированной структуры папок проекта и общих подходов к разработке решения. Например, при разработке формы - описание данных оформлять как тип в отдельном файле, с тем, чтобы иметь возможность использовать его и в родительском, и в дочернем компонентах. Если пустить разработку на самотёк, она очень быстро захламиться и её сопровождение будет критически усложнено.

## Способы упростить разработку на React

В статье [Быстрый Frontend в 2025: почему RTK Query, Tailwind и Vite убивают классические подходы](https://habr.com/ru/articles/918558/) рассматривается возможность использования RTK Query, Tailwind и Vite для ускорения разработки front-end на React.

Tailwind должен упростить работу с таблицами стилей.

RTK Query позволяет заменить разработки Action-ов/Reducer-ов (State Management) в случае использования Redux Thunk. Типовой код на Redux + Axios:

```js
const fetchPosts = () => async (dispatch) => {
    dispatch({ type: 'FETCH_POSTS_REQUEST' });

    try {
        const res = await axios.get('/api/posts');
        dispatch({ type: 'FETCH_POSTS_SUCCESS', payload: res.data });
    } catch (err) {
        dispatch({ type: 'FETCH_POSTS_FAILURE', error: err.message });
    }
};
```

Тоже самое "из коробки" от [RTK Query](https://redux-toolkit.js.org/rtk-query/overview) (Redux Toolkit):

```js
const { data, error, isLoading } = useGetPostsQuery();
```

Vite, как Package Manager гораздо более быстрый и менее сложный, чем WebPack.

## Терминология React

Определяются неконтролируемые компоненты и компоненты контролируе React.

Неконтролируемые компоненты (_uncontroller components_) - это элементы обычной HTML-верстки, например:

```jsx
const Form = () => {
    return (
        <form>
            <input type="text" />
            <button type="submit">Submit</button>
        </form>
    );
};
```

Пример контролируемого компонента (_controller component_):

```jsx
const Form = () => {
    const [value, setValue] = useState("");
    return (
        <form>
            <input type="text" 
                value={value} onChange={(e) =>
                    setValue(e.target.value)
                } />
            <button type="submit">Submit</button>
        </form>
    );
};
```

## Hook useContext

Контекст в React это способность передачи данных через дерево компонентов, минуя прокидывание данных через _props_ от одного компонента к другому.

До создания State Management (Redux и Mobx) данные передавались от самого верхнего компонента к нижним через props, иногда минуя огромные цепочки связанных компонентов. Этот подход избыточен и отличается низкой эффективностью. Для решения проблемы в React был введён **Context API**.

>Довольно часто Context используется для визуализации список с каким-то одним активным элементом: закладки (Tab-ы), меню, Accordion, и т.д. В этом случае родительский элемент группирует дочерние, а действия над дочерним элементом (click) влияет на все элементы группы. Т.е. можно говорить о том, что **Context** позволяет создавать групповое поведение для некоторой иерархиии компонентов, в которой изменение одного дочернего элемента затрагивает другие элементы.

Создать контекст можно используя функцию React.createContext(), которая имеет единственный параметр - значение по умолчанию, или объект для передачи дочерним компонентам через контекст. 

```js
const context = React.createContext('value');
```

Функция React.createContext() создаёт два компонента: провайдера и потребителя:

```js
<Сontext.Provider value={"value"}>
```

```js
<Context.Consumer>
   { value = > <div>value</div> }
</Context.Consumer>
```

Часто в приложении не хватает одного контекста, но React позволяет создавать несколько разных контекстов.

### Практический пример использования контекста

```js
const AccordionContext = createContext({
    activeItemIndex: 0,
    setActiveItemIndex: () => 0,
});
```

Результат вызова createContext() может быть использован в JSX-верстке, например:

```js
export const Accordion = ({items}) => {
    const [activeItemIndex, setActiveItemIndex] = useState(0);

    return (
        <AccordionContext.Provider value={{ activeItemIndex, setActiveItemIndex }}>
            <ul>{children}</ul>
        </AccordionContext.Provider>
    );
};
```

>Заметим, что **children** в React - это особенное зарезервированное свойство, которое содержит дочерние JSX-элементы.

В приведённом выше коде мы создали контекст, в котором определена переменная состояния и функция для изменения состояния.

Далее мы можем определить дочерний компонент, экземпляры которого будут использовать этот контекст для re-rendering-а. Заметим, что родительский компонент создал состояние (state), а дочерние элементы используют контекст.

Вот как может выглядеть дочерниий компонент:

```js
export const AccordionItem = ({item, index}) => {
    const { activeItemIndex, setActiveItemIndex } = useContext(AccordionContext);

    return (
        <li onClick={() => setActiveItemIndex(index)} key={item.id}>
            <strong>{item.label}</strong>
            {index === activeItemIndex && item.content}
        </li>
    );
}
```

В приведённом выше коде мы определяем элемент списка, который вызывает метод изменения контекста при щелчке на элемент, что приведёт к установке конкретного дочернего элемента в активное состояние, а так же, поскольку состояние контекста измениться, то выполнит ре-рендеринг родительского компонента.

Использовать компонент Accordion мы можем, например, таким образом:

```js
const items = [
    {label: "One", content: "lorem ipsum for more, see http://one.com"},
    {label: "Two", content: "lorem ipsum for more, see http://two.com"},
    {label: "Threee", content: "lorem ipsum for more, see http://three.com"},
];

<Accordion>
    {items.map((item, index) => (
        <AccordionItem key={item.id} item={item} index={index} />
    ))} 
</Accordion>
```

Чем хорош данный подход: рендерингом управляем родительский элемент, тогда как дочерние элементы имеют информацию о текущем состоянии родительского элемента.

Заметим также, что контекст доступен для вложенных на большую глубину элементов, а верстка может содержать различные дополнительные элементы, такие, например, как разделительная линия элементов.

По всей видимости, близким "родственником" в Blazor является _CascadingParameter_.


## Шаблон проектирования - разделение на презентационный и контейнерный компоненты

Рекомендуется разделять код, в котором есть верстка и получение данных через API на два компонента, с разными зонами ответсвенностями:

```js
// Компонент отвечает за представление данных (Presentation)
function UserList({ users }) {
    return (
        <ul>
        {users.map(user => <li key={user.id}>{user.name}</li>)}
        </ul>
    )
}

// Компонент отвечает за получение данных через API
function UserListContainer() {
    const [users, setUsers] = React,useState([]);

    React.useEffect(() => {
        fetch('/api/users')
            .then(res => res.json())
            .then(data => setUsers(data));
    }, []);

    return <UserList users={users} />;
}
```

## Шаблон проектирования - использование Custom Hooks

Чтобы уменьшить дублирование кода, некоторые типовые действия, например, загрузку JSON с сайта, рекомендуется оформлять как отдельный пользовательский hook. Например:

```js
// Компонент осуществляет загрузку данных через API. Это пользовательский Hook
function useFetch(url) {
    const [data, setData] = React.useState(null);

    React.useEffect(() => {
        fetch(url)
            .then(res => res.json())
            .then(setData);
    }, [url]);

    return data;
}

// Компонент загружает данные через пользовательский Hook и формирует верстку
function Profile() {
    const user = useFetch('/api/user');

    if (!user) return <p>Loading...</p>;
    return <h1>{user.name}</h1>;
}
```

## Загрузка картинок

Поскольку React выполняет _bundling_ компонентов, включая изображения, необходимо использовать относительный путь к картинкам в приложении. Например:

```js
import React from 'react';
import logoImage from '../assets/logo.png'; // Относительный путь к изображению

const MyComponent: React.FC = () => {
  return (
    <div>
      <img 
        src={logoImage} 
        alt="Company Logo" 
        className="logo" 
      />
    </div>
  );
};

export default MyComponent;
```

## Синтаксический сахар при передаче props

Предположим, что у нас есть массив объектов, в которых хранятся повторяющаяся информация: картинка (image), заголовок (title), текстовое описание (description). Мы можем передавать в компонент объект целиком. В верстке это может выглядеть следующим образом:

```js
<CoreConcept {...CORE_CONCEPT[0]} />
```

В приведённом выше примере CORE_CONCEPT является массивом объектов и все элементы этого объекта будут переданы в компонент в виде отдельных свойств (_props_). Это возможно благодаря использованию _spread/rest operator_.

При определении компонента мы можем использовать _destructuring_ для излечения этих props по имени, например:

```js
function CoreConcept({image, title, description}) {  

}
```

## Обработка событий в JSX

Примеры вызова обработчиков событий при нажатии на экранную кнопку:

```tsx
import React, { useState } from 'react';

function ButtonExample() {
  const [count, setCount] = useState(0);

  const handleClick = () => {
    setCount(count + 1);
    console.log('Button was clicked!');
  };

  const handleSpecificClick = (message) => {
    alert(message);
  };

  return (
    <div>
      <button onClick={handleClick}>
        Clicked {count} times
      </button>

      <button onClick={() => handleSpecificClick('Hello, World!')}>
        Click me with a message
      </button>

      <button onClick={(e) => {
        console.log('Inline click handler');
        console.log('Event object:', e);
      }}>
        Inline Handler
      </button>
    </div>
  );
}

export default ButtonExample;
```

В типовой ситуации мы просто передаём через атрибут JSX-объекта указатель на функцию: `<button onClick={handleClick}>`. Важно помнить о том, что внутри фигурных скобок мы указываем JavaScript-код. Если мы указываем `handleClick`, то эта синтаксическая конструкция возвращает указатель на функцию, а если указываем `handleClick()` (и это синтаксически корректно), то возвращаем результат вызова функции **handleClick**().

Если при возникновении события нам нужно передать какую-то информацию в обработчик события, то в типовом случае следует использовать анонимную функцию:

```tsx
<button onClick={() => handleSpecificClick('Hello, World!')}>
```

## Conditional Rendering

В React используются типовые трюки для осуществления условного rendering-а. Наиболее простой вариант состоит в использовании тернатного оператора совместно с JSX, например:

```tsx
{selectedTopic ? (<p>Выбран: {selectedTopic}</p>) : (<p>Раздел не выбран</p>)}
```

Однако чаще встречается конструкция с использованием логического оператора &&:

```tsx
{selectedTopic && (<p>Выбран: {selectedTopic}</p>))}
```

Смысл конструкция в том, что если selectedTopic будет равен null, или undefined, то в соответствии с правилами использования логического "И", следующее "условие" проверяться уже не будет, т.к. условие уже лживое (false). Но если условие правдивое (true), то statement, следующий за && будет выполнен. И здесь срабатывает трюк транспайлера JSX, который для "вычисления условия" выполнит последовательность, которая, в свою очередь, добавит в верстку необходимые элементы. Так происходит потому, что JSX транслируется в последовательность функций, которые вполне могут быть использованы в логической цепочке, т.е. синтаксически конструкция является правильной, хотя она не проверяет условие, а участвует в генерации верстки.

## Использование map()

JSX может быть использован в массивах, например:

```tsx
{[<p>Hello</p>, <p>World</p>]}
```

В React очень часто встречается следующий код:

```tsx
return (
    <>
    {EXTERNAL_ARRAY.map((item) => (
        <CustomControl key={index} {...item} />
    ))}
    </>
);
```

Атрибут key необходим React-у для того, чтобы корректно осуществлять управление rendering-ом. Мы должны устанавливать этот атрибут в любое уникальное значение.

## Что такое Fragment в React

Компонент React возвращает только один React-элемент. Однако, мы можем включить любое количество дочерних элементов в этот компонент верхнего уровня.

Пример кода React-компоненты, в котором не используется JSX:

```tsx
import React from 'react';

interface UserProfileProps {
  name: string;
  age: number;
}

const UserProfile: React.FC<UserProfileProps> = ({ name, age }) => {
  return React.createElement(
    'div', 
    { className: 'user-profile' }, 
    React.createElement('h1', null, `Name: ${name}`),
    React.createElement('p', null, `Age: ${age}`),
    React.createElement(
      'button', 
      { onClick: () => console.log('Button clicked') }, 
      'Click me'
    )
  );
};

export default UserProfile;
```

Если разрабатываемый компонент должен вернуть несколько элементов на одном уровне, нам (гипотетически) необходимо упаковать его в родительский элемент. И на первый взгляд, кажется что логично обернуть элементы в div. В действительности, такое решение не очень хорошее, потому, что такой div на верхнем уровне будет перенесён в DOM и создаст дополнительный уровень вложенности, что создаёт избыточность. 

Разработчики React придумали специальный тип компонентов - Fragment, который может использоваться в разметке, но при транспиляции кода из JSX в JavaScript/TypeScript, он не будет включён в DOM. Т.е. по сути, это обёртка для того, чтобы обойти некоторое ограничение React.

В новых версиях React, Fragment был заменён на синтаксический сахар `<>...</>`, что делает код ещё более понятным и прямолинейным.

Однако про концепцию Fragment нужно знать, т.к. существует огромное количество унаследованного кода, в котором Fragment-компоненты активно используются.

## Refs & Portals

Иногда, даже простые действия в React могут требовать большого количества состояний (States). Предположим, что нам нужно отобразить на экране поле для ввода имени пользователя и кнопку Submit. В типовом решении, нам потребуется добавить состояния "имя пользователя" и "был-ли выполнен submit":

```js
const [enteredPlayerName, setEnteredPlayerName] = useState(null);
const [submitted, setSubmitted] = useSate(false);
```

Кажется, что в коде слишком много лишнего кода. Решить эту проблему можно используя Refs.

Определить Refs можно используя специальный hook - useRef:

```js
import { useState, useRef } from 'react';

export default function Player() {
    const playerName = useRef();
```

```js
<input ref={playerName} type="text" onChange={handleChange} value={enteredPlayerName} />
```

Ref - это переменная, которая хранит ссылку на конкретный JSX-элемент в верстке. Сначала мы должны создать ссылку в JavaScript/TypeScript-коде, а затем проинициализировать её в описании JSX-компонента. После этого мы можем использовать эту ссылку для изменения JSX-элемента. Например:

```js
function handleClick() {
    setEnteredPlayerName(playerName.current.value);
}
```

Следует заметить, что `current` - это реальная ссылка на DOM-элемент. В приведённом выше примере мы можем напрямую изменять конкретное состояние формы, за счёт ручного управления, убрать часть избыточных состояний (в привере выше - мы можем избавиться от submitted).

Ref очень удобен для ручного управления JSX/DOM-элементов. И конечно же мы может не только изменять состояния формы, но и напрямую влиять на DOM-элементы. Например мы можем сбросить состояние строки ввода следующим образом:

```js
playerName.current.value = '';
```

Однако следует заметить, что основная парадигма React - описание задачи в декларативном стиле, а не ручное управление DOM, т.е. в определённом смысле, Refs нарушает "чистоту React". Именно в этом и состоит основная проблем Refs - он смешивает императивный и декларативный стили программирования в приложении.

Также есть ещё одна проблема - мы не можем использовать конструкции вида `playerName.current.value` в JSX-верстке, т.к. при первом рендеринге, значение ссылки playerName ещё не привязано к JSX-элементу. По этой причине, Refs рекомендуется использовать только в JavaScript-функциях обработчиках событий.

Тем не менее, есть возможность обойти ограничение посредством тернарного оператора:

```js
<ht>Welcome {playerName.current ? playerName.current.value : 'unknown entity'}</h2>
```

Но тут возникает другая проблема - при перерендеринге компонента, DOM-элементы могут пересоздаваться, т.е. их состояние будет потеряно. В этом и состоит главное отличие Refs от State Values. State Values позволяют сохранить состояние компонента при его перерендеринге, а Refs - нет.

Также очень важно знать, что Refs - это эффективный способ получить доступ к Browser APIs из React-приложения.

### Работа с таймерами

Фундаментальная проблема, связанная с таймерами состоит в том, что при re-render-е компонента (если возникнет любое обновление компонента, изменяющее его state), он повторно запускается и значение переменных, определённых внутри компонента будут потеряны.

Например, мы можем запустить таймер используя обычный JavaScript-код, например:

```js
const [timerExpired, setTimerExpired] = useSate(false);

function handleStart() {
    setTimeout(() => {
        setTimerExpired(true);
    }, tragetTime * 1000);
}
```

Но если мы попробудем сохранить его идентификатор и выполнить `clearTimeout(timer)` когда будет нажата некоторая кнопка в компоненте, идентификатор timer не будет валидным и таймер не остановится. Т.е. мы не можем написать что-то типа:

```js
const [timerExpired, setTimerExpired] = useSate(false);

let timer;

function handleStart() {
    timer = setTimeout(() => {
        setTimerExpired(true);
    }, tragetTime * 1000);
}
```

Решить эту проблему можно либо если мы вынесем таймер за пределы компонента, либо применить Refs. Первый случай лишает нас возможности использовать несколько экземпляром компонента в форме, т.е. это не вариант для промышленных приложений. А вот Refs подходит нам идеально! Для этого нам просто достаточно создать Ref: `const timer = useRef();`, а затем использовать его следующим образом:

```js
function handleStart() {
    timer.current = setTimeout(() => {
        setTimerExpired(true);
    }, tragetTime * 1000);
}

function handleStart() {
    clearTimeout(timer.current);
}
```

Refs не теряется при повторном ре-рендеринге и его вполне можно использовать для хранения идентификатора таймера. При этом он не оказывает явного влияния на пользовательский интерфейс, но хранит данные, которые можно использовать в императивном JavaScript-коде.

### Modals - модальный диалог

Допустим, что у нас есть некоторый компонент, который реализует поведение модального диалога:

```js
export default function ResultModal({result, targetTime}) {
    return <dialog className="result-modal" open>
        <h2>You {result}</h2>
        <p>The target time was <strong>{targetTime} seconds</strong></p>
        <form method="dialog">
            <button>Close</button>
        </form>
    </dialog>;
}
```

По факту, мы должны управлять этим модальным диалогом вручную в императивном режиме. И в этом случае, Refs - наилучшее решение.

В коде, который использует модальный диалог мы добавляем атрибут "ref":

```js
const dialog = useRef();
...
<ResultModal ref={dialog} targetTime={targetTime} result="lost" />
```

А в реализации компонента инициализируем ref через обычный DOM-элемент:

```js
export default function ResultModal({ref, result, targetTime}) {
    return <dialog ref={ref} className="result-modal" open>
```

После этого мы можем использовать в JavaScript-коде управляющем компонентом традиционные операции императивного JavaScript:

```js
dialog.current.showModal();
```

`showModal`() - это функция DOM-элемента [dialog](https://developer.mozilla.org/en-US/docs/Web/API/HTMLDialogElement/showModal).

Эта техника называется _Forwarding Refs to Custom Components_.

Это работает начиная с React 19. Для более старых версий React следует использовать _wrapper_ **forwardRef**:

```js
import { forwardRef } from 'react';

const ResultModal = forwardRef(function ResultModal({result, targetTime}, ref) {
...

export default ResultModal;
```

Полные примеры приведены в [решениях задачи на Udemy](https://github.com/Kerminator1973/ReactDataTables/blob/main/udemy_exercises.md).

### Альтернативные способ использования императивного кода

В приведённом выше примере, мы вынуждены вызывать императивный код для элементов, определённых внутри компонента снаружи этого компонента. Мы определили DOM-элемент dialog внутри компонента ResultModal, а используем его снаружи: `dialog.current.showModal();`. Что устранить это неудобство используется другой hook - useImperativeHandle.

Основная идея состоит в том, что мы можем определить API, который будет передаваться во внешний код для императивного использования. Этот API, как раз, и определяется посредством в useImperativeHandle():

```js
import { forwardRef, useImperativeHandle, useRef } from 'react';

const ResultModal = forwardRef(function ResultModal({result, targetTime}, ref) {
    const dialog = userRef();

    useImperativeHandle(ref, () => {
        return {
            open() {
                dialog.current.showModal();
            }
        }
    });

    return (
        <dialog ref={dialog} className="result-modal">
            ...
    )
```

Как только мы использовали `useImperativeHandle()`, параметр **ref** во внешнем коде будет указывать на API, а не на DOM-элемент. Соответственно, во внешнем коде мы теперь можем написать так:

```js
function handleStart() {
    timer.current = setTimeout(() => {
        setTimerExpired(true);
        dialog.current.open();  // <-- Вот здесь осуществляется вызов метода API
    }, targetTime * 1000);

    setTimerStarted(true);
}
```

Этот подход гораздо больше напоминает компонентный и лучше подходит для групповой разработки ПО.

## Portals

Когда мы работаем с модальными диалогами в web-приложениях, может быть целесообразно работать с ними на уровне вложенных компонентов, а верстку размещать в начале HTML-документа. Например, все модальные диалоги должны быть размещены на уровне App, в начале HTML-документа.

Для того, чтобы делать подобные вещи, в React есть специальный механизм, который называется **Portal** и обеспечивает телепортацию сформированной верстки в любое место документа.

Для того, чтобы использовать портал, необходимо загрузить специальный wrapper - createPortal. Компонент, верстка которого телепортируется должен быть обёрную в createPortal:

```js
import React, { useState } from "react";
import {createPortal} from "react-dom";

function Modal({ children, onClose }) {
  // Портал рендерит содержимое в #modal‑root,
  // а не в обычный DOM‑дерево компонента
  return createPortal(
    <div className="overlay" onClick={onClose}>
      <div className="content" onClick={e => e.stopPropagation()}>
        {children}
        <button onClick={onClose}>Close</button>
      </div>
    </div>,
    document.getElementById("modal-root")
  );
}
```

Второй параметр функции `createPortal()` - это DOM-элемент в App.js (обычно в "App.js"), в который следует телепортировать верстку. В приведённом выше примере, для получения DOM-элементы мы используем `document.getElementById("modal-root")`. Соответственно, в "App.js" должен быть определён контейнер для этой трансформации:

```html
<div id="modal-root"></div>
```
