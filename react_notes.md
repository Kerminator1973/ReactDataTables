# Заметки об использовании React

Начать нужно с того, что делает React (или Blazor, или другой инструмент, реализующий декларативное программирование), по сути, безальтернативным при разработке web-приложений.

Ключевым для обеспечения качества работы приложения является его умение контролировать изменение состояния. В случае, если мы используем Vanilla JavaScript, изменение состояния носит хаотичный характер. Управление добавлением, или удалением элементов, подписок, и т.д., крайне сложно надёжно реализовать вручную.

Обычно, код написанный на Vanilla JavaScript является очень хрупким. Основные проблемы:

- **Unsafe**: обработчик некоторого события (например, нажатия на кнопку) может быть легко переопределён другим JavaScript-кодов на странице. Чтобы избежать этого мы можем использовать addEventListener, но в этом случае мы должны аккуратно вызывать removeEventListener, чтобы избежать утечки ресурсов и замедления работы приложения
- **Unpredicatable**: в случае большого объёма верстки можно легко ошибиться в написании идентификатора и, в частности, получить коллизию имён элементов DOM, которая может быть обнаружена в очень редких случаях
- **Inefficient**: операция изменения DOM (_mutation_) является очень дорогой и кажется важным накапливать изменения и осуществлять их одной большой операцией, а не множеством мелких операций

React решает приведённые выше проблемы, добавляя к этому возможности примеения императивного программирования. Преимущество подхода состоит в том, что используя JSX (Javascript Syntax eXtension) мы описывам то, что мы хотем увидеть, а не то, как мы достигаем результата.

>Для всех файлов с расширениями ".jsx" и ".tsx" применяется JSX-транспайлер, который применяет токенайзер (lexer) для выделения отдельных токенов в файле, затем осуществляет парсинг выполняя построение **синтаксического дерева**, которое можно представить в виде JSON-документа. На следующем этапе, осуществляется генерация JavaScript-кода, соответствующего содержимому синтаксического дерева.
>
>Таким образом мы переходим от конструкции `(<Box prop="value">Ящик</Box>)` к JavaScript-коду `React.createElement(Box, {prop: "value"}, "contents");`.
>
>Здесь возникают следующие потери:
>
>- транспиляция требует времени и цепочка транспиляции может быть большой (TSX -> TypeScript, TypeScript -> JavaScript)
>- трансляция JavaScript в браузере, может значительно влиять на время запуска приложения

### Почему Custom Components начинаются с заглавной буквы

React смотрит на регистр первой буквы в имени компонент и принимает решение о том, является ли компонент встроенным (стандартным компонентов HTML), или компонентом JSX. Встроенный компонент используется без изменений, тогда как JSX-компонент преобразовывается в JavaScript-код транспайлером.

### Полезные трюки в React

Выражения (**Expressions**) в JSX - мощный инструмент:

```jsx
const a = 1;
const b = 2;

const MyComponent = () =>
    <Box>Здесь используется выражение: {a + b}</Box>
```

В выражениях мы може использовать тернарный оператор, ветвление - вообще, что угодно:

```jsx
const MyComponent = () =>
    <Box>Выражение: {b > a ? "YES" : "NO"}</Box>
```

```jsx
const MyComponent = () =>
    <Box>Выражение: {
        const a = 1;
        const b = 2;

        if (a > b) {
            3
        }
    }</Box>
```

## Критика

Модель рендеринга React обладает низкой вычислительной эффективностью. Основные причины:

- однопоточность (асинхронность помогает лишь отчасти)
- полный ре-рендеринг компонентов при возникновении изменений (мемоизация помогает лишь отчасти)

Рекомендуется просмотр видео [React мемоизация - useCallback, useMemo, memo](https://rutube.ru/video/4c3df952aa240c1a653a6884718bea82/) by "Позитивный подъем".

Рендеринг компонента - это выполнение JavaScript-кода, размещённого внутри этого компонента, включая JavaScript-код, который создаётся транспиляцией TSX в многоступенчатые вызовы React.createElement(). Например, при рендеринге/повторном рендеринге компонента EmployeeModal будут создаваться контексты выполнения для всех вызовов внутри функции EmployeeModal(). В случае использования состояний (useState()), создаваемые функции не будут сохраняться в области данных React, но создаваться они всё равно будут. Отчасти проблема может быть решена посредством мемоизации, но этот вид оптимизации необходимо выявлять вручную, вручную мемоизировать (React.memo(), useCallback()), а затем вручную проверять её эффективность.

>Возможно, ситуация улучшилась в React 19, но уверенности в этом нет.

Т.е. любая активность, связанная с пользовательским интерфейсом, будет приводить к значительному расходу вычислительных ресурсов, гигантская часть которых будет расходоваться впустую, т.к. React будет отвергать сгенерированные функции.

Мы можем говорить о том, что действия, связанные с пользовательским интерфейсом инициируются "медленным" человеком, а ресурсов современного компьютера достаточно, чтобы спокойно отнестись к холостой работе процессора в кратковременные моменты времени, но вычислительные возможности компьютеров тоже бывают разными.

Так же следует обратить внимание, что React хранит VirtualDOM, состояния и ещё кучу всего в оперативной памяти, что приводит к её повышенному расходу. Это опять же, может быть не заметно на современных компьютерах, но существуют компьютеры, на которых недостаток памяти может приводить и к серьёзным проблемам с производительностью.

Резюмируя: вычислительная эффективность React крайне низкая.

## Компонентная модель, в целом - здорово

При разработке приложения на React крайне важно осуществлять авторский контроль и систематически заниматься улучшением кода.

В первом варианте приложения, список свойств модального диалога получился очень большим:

```tsx
<EmployeeModal 
    isOpen={isModalOpen}
    isEditMode={isEditMode}
    setModalShow={setModalShow}
    surnameField={surname} 
    setSurnameField={setSurname} 
    positionField={position} 
    setPositionField={setPosition}
    onSubmit={handleSubmit}
/>
```

А также определяются в дочерних компонентах:

```tsx
type ModalComponentProps = {
    isOpen: boolean;
    isEditMode: boolean;
    setModalShow: (state: boolean) => void;
    surnameField: string;
    setSurnameField: React.Dispatch<React.SetStateAction<string>>;
    positionField: string;
    setPositionField: React.Dispatch<React.SetStateAction<string>>;
    onSubmit: () => void;
};

const EmployeeModal: React.FC<ModalComponentProps> = ({ 
    isOpen, isEditMode, setModalShow, surnameField, setSurnameField, positionField, setPositionField, onSubmit,
}) => {
```

>React.FC<> это синоним React.FunctionComponent<>.

Однако потом было принято решение использовать отдельный тип для хранения состояния объекта "модальный диалог". Описание состояния было вынесено в отдельный файл - "types.ts":

```ts
export type EmployeeData = {
  surname: string;
  position: string;
};
```

И сам модальный диалог, и его родительский компонент импортируют этот тип:

```ts
import { EmployeeData } from './types';
```

В результате хранения состояния в виде объекта, позволило значительно сократить количество свойств модального диалога:

```ts
type EmployeeModalProps = {
    show: boolean;
    isEditMode: boolean;
    initialData?: EmployeeData;
    onClose: () => void;
    onSubmit: (data: EmployeeData) => void;
};
```

Важным изменение в коде также является делегирование решение о закрытии модального диалога родительскому компоненту, что позволяет, например, не закрывать модальное окно, если валидация данные завершилась не корректно.

## Вынос состояния в родительский компонент - OK, но не совсем

Состояния определяются в родительском окне и передаются через props в дочерние:

```ts
function App() {

    // Определяем состояние "активатор модального окна"
    const [isModalOpen, setModalShow] = useState(false);

    // Определяем режим работы модального окна
    const [isEditMode, setEditMode] = useState(false);

    // Определяем состояния полей для ввода ФИО и должности
    const [surname, setSurname] = useState<string>('');
    const [position, setPosition] = useState<string>('');
```

Это лишь отчасти напоминает шаблон проектирования MVVM. В MVVM есть ModelView, в котором находятся все необходимые атрибуты, разные Views могут использовать один общий ModelView и передавать каждому дочернему компоненты все необходимые ему свойства через props не нужно.

Подход React выглядит избыточным. Допускаю, что в сложных формах он может быть чрезвычайно избыточным.

>Решением проблемы с избыточностью является добавление в приложение _state management_. Главная задач state management в React и состоит в том, чтобы избежать длинных маршрутов доставки изменений. Шаблон проектирования Publish/Subscribe подходит для этого, практически, идеально.
>
>Однако негативным следствием введения в систему state management является усложнение кода и логики, а также необходимость выбора внешней библиотеки, соответствующей типу приложения.
>
>Заметим, что в Blazor сделана попытка избежать внедрения state management за счёт использования каскадирования параметров (CascadingParameter). Однако каскадирование работает для простых иерархических схем, а для сложных связей всё равно приходится вводить в систему state management.

## К "синтаксическому сахару" можно привыкнуть, но он не очевидный

Пример:

```tsx
<Modal.Title>
    {isEditMode === false && (
        <>Добавление нового сотрудника</>
    )}
    {isEditMode === true && (
        <>Редактирование сотрудника</>
    )}
</Modal.Title>
```

Привыкнуть можно, но выглядит это как китайский иероглиф, т.е. его придётся выучить, он не очевиден сам по себе.

## Вызов методов дочерних компонентов требует значительных усилий

Императивный стиль программирования React не любит, предпочитая декларативный. Однако в сложных приложениях избежать использования императивного стиля невозможно.

См.: forwardRef, useImperativeHandle, Ref.

Существуют компоненты, которые предоставляют API, а не только props. Хороший пример - таблица DataTables.NET.

Нужно определить экспортируемый тип, затем использовать useImperativeHandle(), чтобы _to expose_ функции родительскому элементу. Родитель также должен использовать useRef(), чтобы воспользоваться методами дочернего компонента.

## Что же в React есть хорошего?

React реализует компонентную модель и она работает. Но она медленная и работает со значимыми ограничениями.

TypeScript работает хорошо. AutoComplete в VSCode - надёжный, проверки типов Linter-ом даёт ложные срабатывания, но, в целом, работает.

Интеграция с Bootstrap 5 и DataTables.NET, на мой взгляд, на четыре с плюсом. Один плюсик потерян из-за того, что есть множество не очевидных моментов, которые приходится искать (иногда с большим трудом).

Несомненно, к хорошему можно отнести Plug-in для Chrome **React Developer Tools**, который позволяет просматривать структуру VirtualDOM, данные, которые хранит React, а также содержит Profiler, посредством которого можно оценивать, рендеринг какого из компоненентов занял больше всего времени в конкретный re-render. Создаётся впечатление, что DevTool действительно очень хороший, полезный инструмент.

## Оценка будущего React

В 2025 году, всё совсем не однозначно. Основная проблема инструмента - фрагментация. Ключевое направление развития React - SSR (Server-Side Rendering), решающий многие из проблем существующих React-приложений.

Три вещи, которые нужны для работы SSR:

- Bundler, который умеет разделять код на серверные и клиентские компоненты
- Server, который загружает js bundle, формирует контент и передаёт его клиентскому компоненту
- Client-Side Router, который умеет разделять трафик на клиентский и серверный

Проблема состоит в том, что React/SSR нарушает идеоматический способ разработки React-приложений. Более того, развитие различных React/SSR библиотек очень сильно ломает общую концепцию, библиотеки все более и более не совместимым друг с другом. Т.е. выбирая React в качестве основной платформы разработчики должны выбрать "традиционный React", или SSR, а потом ещё и угадать, какую с SSR-библиотек использовать. С учётом жёсткой конкуренции между разработчиками альтернативных библиотек, вероятность принятия правильного решения (LTS проекта на 10 лет) в этой "угадайке" не очень высокая.

При этом, тот факт, что React/SSR ориентируется на Node.js на стороне сервера - это сильный сдерживающий фактор, т.к. оставляет "за бортом" растущие эко-системы: Go lang, .NET Core, Rust, Java Next.

Дополнительно, есть существенное давление со стороны альтернативных разработок:

- Vue.js (на подъёме)
- Angular (падение, но пока не свободное)
- Svelte, Blazor (странная, леворезьбовая история)
- развитие экосистемы WASM

Из приведённых выше, наиболее опасным для React является развитие Vue.js

## Где закопаны основные потери в React

JSX трансформируется в JavaScript-код, который выглядит как:

```js
React.createElement('div', null, 
    [React.createElement(...), ...],
React.createElement(...)
)
```

Для отображения контента, React сначала формирует RenderTree, создавая элементы (они были определены в JSX) этого дерева, в затем выполняет полный проход по дереву, чтобы сформировать VirtualDOM.

Если при обработке событий изменяется состояние какого-то элемента (например, вызывается функция, который ранее вернул useState()), то снова строиться всё дерево, формируется новый RenderTree. Затем старый и новый VirtualDOM сравниваются, различия отражаются в DOM браузера.

Поскольку изменение DOM браузера очень медленное, обновление только отличий значительно улучшает производительность приложения.

Однако, приложению нужно значительно больше памяти (чтобы хранить последний VirtualDOM, а также данные React, включая состояния). Кроме этого, при каждом изменении создаётся новый RenderTree, который может быть просто огромного размера. Следует заметить, что вызов каждой функции JavaScript создаёт контекст вызова и всё это требует значимых вычислительных ресурсов.

Таким образом, основные потери React закопаны в:

- формировании RenderTree при изменении любого состояния приложения (см. useState)
- обходе всего RenderTree для формирования VirtualDOM
- сравнении предыдущего и нового VirtualDOM
- обновлении DOM браузера

С учётом того, что JavaScript однопоточный, улучшить отзывчивость системы, например, увеличив количество ядер процессора невозможно. Более того, частота процессора, на котором работает является критичной.

>Из вышесказанного можно сделать два дополнительных вывода:
>
>- работа React-приложений на процессорах в которых нет мощных P-ядер (хотя бы одного) - это потенциальная проблема
>- SSR отлично утилизирует многоядерность сервера, разгружая клиентские компьютеры

### Что думают разработчики о React

Развиваясь, React приложение создаёт безумный client-side state для доступа к серверу и тянет за собой безумое развитие server-side. И для того, чтобы бороться с этим безумием, React-разработчики мигрируют на React/SSR.

Однако, в 2025 году есть целая куча конкурирующих SSR-решения в эко-системе React и выбрать подходящий сложно. К сожалению, использование Node.js/TypeScript на сервере лишает разработчиков огромного количества удобств и классных инструментов, таких как LINQ и EF в .NET.

Рекомендуется для ознакомления обсуждение на [Reddit](https://www.reddit.com/r/Blazor/comments/17irng3/blazor_the_end_of_react/?rdt=42081)

### Мемоизация - способ снизить вычислительную нагрузку

Предположим, что у нас в JSX определена кнопка:

```jsx
const [counter, setCounter] = useState(0);
const increase = () => setCounter((s) => s + 1);

return(
    <div>
        <FancyButton onClick={increase}>
            Increase counter
        </FancyButton>
        <Counter value={counter} />
    </div>
);

const Counter = ({value}) => {
    return <div>{value}</div>;
};

const FancyButton = ({onClick, children}) => {
    return <button onClick={onClick}>{children}</button>;
};
```

Первое, что мы можем сделать - избежать создания новой функции setCounter() при каждом нажатии на FancyButton. Для этого мы можем добавить useCallback():

```jsx
const [counter, setCounter] = useState(0);
const increase = useCallback(() => setCounter((s) => s + 1), [setCounter]);
```

Вызов useCallback() сохранит функцию, указанную в первом параметре в React и при следующем вызове, вернёт её из React-а. Однако, при втором и последующих рендерах анониманая функция с `setCounter((s) => s + 1)` всё равно будет определена. После того, как она будет определена, она будет передана в React и React её отбросит, вернув самый первый вариант функции. Т.к. конкретно в данном случае, никакой реальной оптимизации не будет, т.к. функция всё равно будет определена, а затем проигнорирована React-ом. По сути, мы даже ухудшили производительность и увеличили размер памяти для хранения данных React.

Реальный смысл использования useCallback() есть при его совместном использовании с memo. Чтобы получить реальный выигрыщ, нам нужно мемоизировать FancyButton:

```jsx
const FancyButton = React.memo(({onClick, children}) => {
    return <button onClick={onClick}>{children}</button>;
});
```

Сделав так, мы указываем React-у, что кусочек RenderTree, генерируемый FancyButton должен создаваться по новой только в том случае, если у нас изменяется либо onClick, либо children.

И вот тут возникает **самый важный момент** в мемоизации: функция FancyButton не будет генерироваться снова если функция onClick и children не поменяются. И поскольку мы использовали useCallback() для мемоизации функции increase, React использует ранее сформированную FancyButton, а не новую. Совместное использование useCallback() и React.memo() позволит экономить время на повторном рендеринге FancyButton(), хотя функция `() => setCounter((s) => s + 1)` всё равно будет создаваться при каждом рендеринге. Жертвуя малым, мы экономим на большом.

### useMemo()

React.memo() позволяет нам избежать повторного создания функции. useMemo(), в свою очередь, ориентирован на сохранение не функции, а результата её работы.

Допустим, что у нас есть компонент, который генерируем список:

```ts
const UsersList = ({ users }) => {
    return <div>
            <List items={users} />
        </div>;
};

const List = React.memo(({items}) => {
    return items.map(({ id, value}) => <div key={id}>{value}</div>)
});
```

Допустим, мы хотим отображать данные из списка по некоторому условию. Наш код мог бы быть изменён следующим образом:

```ts
const UsersList = ({ users }) => {
    const visibleUsers = users.filter(({ visible }) => visible);
    return <div>
            <List items={visibleUsers} />
        </div>;
};
```

И в этом случае, React.memo() становится совершенно бесполезным, т.к. при каждом выполнении users.filter() мы будем получать новый вариант контейнера (хотя данные будут теми же самыми) и это будет приводить к тому, что при каждой смене состояния компонент UsersList будет полностью перерисовываться. Т.е. React.memo() вместо пользы, начнёт приносить вред, из-за лишнего вызова и расхода памяти в области React-а.

Чтобы у нас действительно появилось улучшение, нужно избегать того, чтобы каждый вызов users.filter() возвращал нам новый список. Для этого и используется useMemo():

```ts
const visibleUsers = useMemo (() => users.filter(({ visible }) => visible), [users]);
```

>Главный вывод: мемоизация - инструмент, который требует от разработчика очень хорошего понимания того, что происходит "под капотом", потому, что при неудачном использовании (которое очень вероятно), производительность приложение не будет улучшена, а скорее всего - сильно ухудшена.
>При выполнении code review следует смотреть на то, используются ли useMemo() и useCallback() без React.memo(). Если используются, что нужно очень
внимательно анализировать код компонента.
>
>Также критичным может быть создание стандартизированной структуры папок проекта и общих подходов к разработке решения. Например, при разработке формы - описание данных оформлять как тип в отдельном файле, с тем, чтобы иметь возможность использовать его и в родительском, и в дочернем компонентах. Если пустить разработку на самотёк, она очень быстро захламиться и её сопровождение будет критически усложнено.

## Способы упростить разработку на React

В статье [Быстрый Frontend в 2025: почему RTK Query, Tailwind и Vite убивают классические подходы](https://habr.com/ru/articles/918558/) рассматривается возможность использования RTK Query, Tailwind и Vite для ускорения разработки front-end на React.

Tailwind должен упростить работу с таблицами стилей.

RTK Query позволяет заменить разработки Action-ов/Reducer-ов (State Management) в случае использования Redux Thunk. Типовой код на Redux + Axios:

```js
const fetchPosts = () => async (dispatch) => {
    dispatch({ type: 'FETCH_POSTS_REQUEST' });

    try {
        const res = await axios.get('/api/posts');
        dispatch({ type: 'FETCH_POSTS_SUCCESS', payload: res.data });
    } catch (err) {
        dispatch({ type: 'FETCH_POSTS_FAILURE', error: err.message });
    }
};
```

Тоже самое "из коробки" от [RTK Query](https://redux-toolkit.js.org/rtk-query/overview) (Redux Toolkit):

```js
const { data, error, isLoading } = useGetPostsQuery();
```

Vite, как Package Manager гораздо более быстрый и менее сложный, чем WebPack.

## Терминология React

Определяются неконтролируемые компоненты и компоненты контролируе React.

Неконтролируемые компоненты (_uncontroller components_) - это элементы обычной HTML-верстки, например:

```jsx
const Form = () => {
    return (
        <form>
            <input type="text" />
            <button type="submit">Submit</button>
        </form>
    );
};
```

Пример контролируемого компонента (_controller component_):

```jsx
const Form = () => {
    const [value, setValue] = useState("");
    return (
        <form>
            <input type="text" 
                value={value} onChange={(e) =>
                    setValue(e.target.value)
                } />
            <button type="submit">Submit</button>
        </form>
    );
};
```

## Hook useContext

Контекст в React это способность передачи данных через дерево компонентов, минуя прокидывание данных через _props_ от одного компонента к другому.

До создания State Management (Redux и Mobx) данные передавались от самого верхнего компонента к нижним через props, иногда минуя огромные цепочки связанных компонентов. Этот подход избыточен и отличается низкой эффективностью. Для решения проблемы в React был введён **Context API**.

>Довольно часто Context используется для визуализации список с каким-то одним активным элементом: закладки (Tab-ы), меню, Accordion, и т.д. В этом случае родительский элемент группирует дочерние, а действия над дочерним элементом (click) влияет на все элементы группы. Т.е. можно говорить о том, что **Context** позволяет создавать групповое поведение для некоторой иерархиии компонентов, в которой изменение одного дочернего элемента затрагивает другие элементы.

Создать контекст можно используя функцию React.createContext(), которая имеет единственный параметр - значение по умолчанию, или объект для передачи дочерним компонентам через контекст. 

```js
const context = React.createContext('value');
```

Функция React.createContext() создаёт два компонента: провайдера и потребителя:

```js
<Сontext.Provider value={"value"}>
```

```js
<Context.Consumer>
   { value = > <div>value</div> }
</Context.Consumer>
```

Часто в приложении не хватает одного контекста, но React позволяет создавать несколько разных контекстов.

### Практический пример использования контекста

```js
const AccordionContext = createContext({
    activeItemIndex: 0,
    setActiveItemIndex: () => 0,
});
```

Результат вызова createContext() может быть использован в JSX-верстке, например:

```js
export const Accordion = ({items}) => {
    const [activeItemIndex, setActiveItemIndex] = useState(0);

    return (
        <AccordionContext.Provider value={{ activeItemIndex, setActiveItemIndex }}>
            <ul>{children}</ul>
        </AccordionContext.Provider>
    );
};
```

>Заметим, что **children** в React - это особенное зарезервированное свойство, которое содержит дочерние JSX-элементы.

В приведённом выше коде мы создали контекст, в котором определена переменная состояния и функция для изменения состояния.

Далее мы можем определить дочерний компонент, экземпляры которого будут использовать этот контекст для re-rendering-а. Заметим, что родительский компонент создал состояние (state), а дочерние элементы используют контекст.

Вот как может выглядеть дочерниий компонент:

```js
export const AccordionItem = ({item, index}) => {
    const { activeItemIndex, setActiveItemIndex } = useContext(AccordionContext);

    return (
        <li onClick={() => setActiveItemIndex(index)} key={item.id}>
            <strong>{item.label}</strong>
            {index === activeItemIndex && item.content}
        </li>
    );
}
```

В приведённом выше коде мы определяем элемент списка, который вызывает метод изменения контекста при щелчке на элемент, что приведёт к установке конкретного дочернего элемента в активное состояние, а так же, поскольку состояние контекста измениться, то выполнит ре-рендеринг родительского компонента.

Использовать компонент Accordion мы можем, например, таким образом:

```js
const items = [
    {label: "One", content: "lorem ipsum for more, see http://one.com"},
    {label: "Two", content: "lorem ipsum for more, see http://two.com"},
    {label: "Threee", content: "lorem ipsum for more, see http://three.com"},
];

<Accordion>
    {items.map((item, index) => (
        <AccordionItem key={item.id} item={item} index={index} />
    ))} 
</Accordion>
```

Чем хорош данный подход: рендерингом управляем родительский элемент, тогда как дочерние элементы имеют информацию о текущем состоянии родительского элемента.

Заметим также, что контекст доступен для вложенных на большую глубину элементов, а верстка может содержать различные дополнительные элементы, такие, например, как разделительная линия элементов.

По всей видимости, близким "родственником" в Blazor является _CascadingParameter_.


## Шаблон проектирования - разделение на презентационный и контейнерный компоненты

Рекомендуется разделять код, в котором есть верстка и получение данных через API на два компонента, с разными зонами ответсвенностями:

```js
// Компонент отвечает за представление данных (Presentation)
function UserList({ users }) {
    return (
        <ul>
        {users.map(user => <li key={user.id}>{user.name}</li>)}
        </ul>
    )
}

// Компонент отвечает за получение данных через API
function UserListContainer() {
    const [users, setUsers] = React,useState([]);

    React.useEffect(() => {
        fetch('/api/users')
            .then(res => res.json())
            .then(data => setUsers(data));
    }, []);

    return <UserList users={users} />;
}
```

## Шаблон проектирования - использование Custom Hooks

Чтобы уменьшить дублирование кода, некоторые типовые действия, например, загрузку JSON с сайта, рекомендуется оформлять как отдельный пользовательский hook. Например:

```js
// Компонент осуществляет загрузку данных через API. Это пользовательский Hook
function useFetch(url) {
    const [data, setData] = React.useState(null);

    React.useEffect(() => {
        fetch(url)
            .then(res => res.json())
            .then(setData);
    }, [url]);

    return data;
}

// Компонент загружает данные через пользовательский Hook и формирует верстку
function Profile() {
    const user = useFetch('/api/user');

    if (!user) return <p>Loading...</p>;
    return <h1>{user.name}</h1>;
}
```
