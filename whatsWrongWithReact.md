# Что мне не понравилось в React, в моём примере

Модель рендеринга React обладает низкой вычислительной эффективностью. Основные причин две:

- однопоточность (асинхронность помогает лишь отчасти)
- полный ре-рендеринг компонентов при возникновении изменений (мемоизация помогает лишь отчасти)

Рекомендуется просмотр видео [React мемоизация - useCallback, useMemo, memo](https://rutube.ru/video/4c3df952aa240c1a653a6884718bea82/) by "
Позитивный подъем".

Рендеринг компонента - это выполнение JavaScript-кода, размещённого внутри этого компонента, включая JavaScript-код, который создаётся транспиляцией TSX в многоступенчатые вызовы React.createElement(). Например, при рендеринге/повторном рендеринге компонента EmployeeModal будут создаваться контексты выполнения для всех вызовов внутри функции EmployeeModal(). В случае использования состояний (useState()), создаваемые функции не будут сохраняться в области данных React, но создаваться они всё равно будут. Отчасти проблема может быть решена посредством мемоизации, но этот вид оптимизации необходимо выявлять вручную, вручную мемоизировать (React.memo(), useCallback()), а затем вручную проверять её эффективность.

>Возможно, ситуация улучшилась в React 19, но уверенности в этом нет.

Т.е. любая активность, связанная с пользовательским интерфейсом, будет приводить к значительному расходу вычислительных ресурсов, гигантская часть которых будет расходоваться впустую, т.к. React будет отвергать сгенерированные функции.

Мы можем говорить о том, что действия, связанные с пользовательским интерфейсом инициируются "медленным" человеком, а ресурсов современного компьютера достаточно, чтобы спокойно отнестись к холостой работе процессора в кратковременные моменты времени, но вычислительные возможности компьютеров тоже бывают разными.

Так же следует обратить внимание, что React хранит VirtualDOM, состояния и ещё кучу всего в оперативной памяти, что приводит к её повышенному расходу. Это опять же, может быть не заметно на современных компьютерах, но существуют компьютеры, на которых недостаток памяти может приводить и к серьёзным проблемам с производительностью.

Резюмируя: вычислительная эффективность React крайне низкая.

## Компонентная модель, в целом - здорово, но очень много избыточности

Под избыточностью я подразумеваю огромные списки props дочерних компонентов. Даже в простом случае модального диалога, мы получаем целую кучу props, которые используются в родительском компоненте:

```tsx
<EmployeeModal 
    isOpen={isModalOpen}
    isEditMode={isEditMode}
    setModalShow={setModalShow}
    surnameField={surname} 
    setSurnameField={setSurname} 
    positionField={position} 
    setPositionField={setPosition}
    onSubmit={handleSubmit}
/>
```

А также определяются в дочерних компонентах:

```tsx
type ModalComponentProps = {
    isOpen: boolean;
    isEditMode: boolean;
    setModalShow: (state: boolean) => void;
    surnameField: string;
    setSurnameField: React.Dispatch<React.SetStateAction<string>>;
    positionField: string;
    setPositionField: React.Dispatch<React.SetStateAction<string>>;
    onSubmit: () => void;
};

const EmployeeModal: React.FC<ModalComponentProps> = ({ 
    isOpen, isEditMode, setModalShow, surnameField, setSurnameField, positionField, setPositionField, onSubmit,
}) => {
```

## Вынос состояния в родительский компонент - OK, но не совсем

Состояния определяются в родительском окне и передаются через props в дочерние:

```ts
function App() {

    // Определяем состояние "активатор модального окна"
    const [isModalOpen, setModalShow] = useState(false);

    // Определяем режим работы модального окна
    const [isEditMode, setEditMode] = useState(false);

    // Определяем состояния полей для ввода ФИО и должности
    const [surname, setSurname] = useState<string>('');
    const [position, setPosition] = useState<string>('');
```

Это лишь отчасти напоминает шаблон проектирования MVVM. В MVVM есть ModelView, в котором находятся все необходимые атрибуты, разные Views могут использовать один общий ModelView и передавать каждому дочернему компоненты все необходимые ему свойства через props не нужно.

Подход React выглядит избыточным. Допускаю, что в сложных формах он может быть чрезвычайно избыточным.

>Решением проблемы с избыточностью является добавление в приложение _state management_. Главная задач state management в React и состоит в том, чтобы избежать длинных маршрутов доставки изменений. Шаблон проектирования Publish/Subscribe подходит для этого, практически, идеально.
>
>Однако негативным следствием введения в систему state management является усложнение кода и логики, а также необходимость выбора внешней библиотеки, соответствующей типу приложения.
>
>Заметим, что в Blazor сделана попытка избежать внедрения state management за счёт использования каскадирования параметров (CascadingParameter). Однако каскадирование работает для простых иерархических схем, а для сложных связей всё равно приходится вводить в систему state management.

## К "синтаксическому сахару" можно привыкнуть, но он не очевидный

Пример:

```tsx
<Modal.Title>
    {isEditMode === false && (
        <>Добавление нового сотрудника</>
    )}
    {isEditMode === true && (
        <>Редактирование сотрудника</>
    )}
</Modal.Title>
```

Привыкнуть можно, но выглядит это как китайский иероглиф, т.е. его придётся выучить, он не очевиден сам по себе.

## Вызов методов дочерних компонентов требует значительных усилий

Императивный стиль программирования React не любит, предпочитая декларативный. Однако в сложных приложениях избежать использования императивного стиля невозможно.

См.: forwardRef, useImperativeHandle, Ref.

Существуют компоненты, которые предоставляют API, а не только props. Хороший пример - таблица DataTables.NET.

Нужно определить экспортируемый тип, затем использовать useImperativeHandle(), чтобы _to expose_ функции родительскому элементу. Родитель также должен использовать useRef(), чтобы воспользоваться методами дочернего компонента.

## Что же в React есть хорошего?

React реализует компонентную модель и она работает. Но она медленная и работает со значимыми ограничениями.

TypeScript работает хорошо. AutoComplete в VSCode - надёжный, проверки типов Linter-ом даёт ложные срабатывания, но, в целом, работает.

Интеграция с Bootstrap 5 и DataTables.NET, на мой взгляд, на четыре с плюсом. Один плюсик потерян из-за того, что есть множество не очевидных моментов, которые приходится искать (иногда с большим трудом).

Несомненно, к хорошему можно отнести Plug-in для Chrome **React Developer Tools**, который позволяет просматривать структуру VirtualDOM, данные, которые хранит React, а также содержит Profiler, посредством которого можно оценивать, рендеринг какого из компоненентов занял больше всего времени в конкретный re-render. Создаётся впечатление, что DevTool действительно очень хороший, полезный инструмент.

## Оценка будущего React

В 2025 году, всё совсем не однозначно. Основная проблема инструмента - фрагментация. Ключевое направление развития React - SSR (Server-Side Rendering), решающий многие из проблем существующих React-приложений.

Три вещи, которые нужны для работы SSR:

- Bundler, который умеет разделять код на серверные и клиентские компоненты
- Server, который загружает js bundle, формирует контент и передаёт его клиентскому компоненту
- Client-Side Router, который умеет разделять трафик на клиентский и серверный

Проблема состоит в том, что React/SSR нарушает идеоматический способ разработки React-приложений. Более того, развитие различных React/SSR библиотек очень сильно ломает общую концепцию, библиотеки все более и более не совместимым друг с другом. Т.е. выбирая React в качестве основной платформы разработчики должны выбрать "традиционный React", или SSR, а потом ещё и угадать, какую с SSR-библиотек использовать. С учётом жёсткой конкуренции между разработчиками альтернативных библиотек, вероятность принятия правильного решения (LTS проекта на 10 лет) в этой "угадайке" не очень высокая.

При этом, тот факт, что React/SSR ориентируется на Node.js на стороне сервера - это сильный сдерживающий фактор, т.к. оставляет "за бортом" растущие эко-системы: Go lang, .NET Core, Rust, Java Next.

Дополнительно, есть существенное давление со стороны альтернативных разработок:

- Vue.js (на подъёме)
- Angular (падение, но пока не свободное)
- Svelte, Blazor (странная, леворезьбовая история)
- развитие экосистемы WASM

Из приведённых выше, наиболее опасным для React является развитие Vue.js

## Где закопаны основные потери в React

JSX трансформируется в JavaScript-код, который выглядит как:

```js
React.createElement('div', null, 
    [React.createElement(...), ...],
React.createElement(...)
)
```

Для отображения контента, React сначала формирует RenderTree, создавая элементы (они были определены в JSX) этого дерева, в затем выполняет полный проход по дереву, чтобы сформировать VirtualDOM.

Если при обработке событий изменяется состояние какого-то элемента (например, вызывается функция, который ранее вернул useState()), то снова строиться всё дерево, формируется новый RenderTree. Затем старый и новый VirtualDOM сравниваются, различия отражаются в DOM браузера.

Поскольку изменение DOM браузера очень медленное, обновление только отличий значительно улучшает производительность приложения.

Однако, приложению нужно значительно больше памяти (чтобы хранить последний VirtualDOM, а также данные React, включая состояния). Кроме этого, при каждом изменении создаётся новый RenderTree, который может быть просто огромного размера. Следует заметить, что вызов каждой функции JavaScript создаёт контекст вызова и всё это требует значимых вычислительных ресурсов.

Таким образом, основные потери React закопаны в:

- формировании RenderTree при изменении любого состояния приложения (см. useState)
- обходе всего RenderTree для формирования VirtualDOM
- сравнении предыдущего и нового VirtualDOM
- обновлении DOM браузера

С учётом того, что JavaScript однопоточный, улучшить отзывчивость системы, например, увеличив количество ядер процессора невозможно. Более того, частота процессора, на котором работает является критичной.

>Из вышесказанного можно сделать два дополнительных вывода:
>
>- работа React-приложений на процессорах в которых нет мощных P-ядер (хотя бы одного) - это потенциальная проблема
>- SSR отлично утилизирует многоядерность сервера, разгружая клиентские компьютеры

### Что думают разработчики о React

Развиваясь, React приложение создаёт безумный client-side state для доступа к серверу и тянет за собой безумое развитие server-side. И для того, чтобы бороться с этим безумием, React-разработчики мигрируют на React/SSR.

Однако, в 2025 году есть целая куча конкурирующих SSR-решения в эко-системе React и выбрать подходящий сложно. К сожалению, использование Node.js/TypeScript на сервере лишает разработчиков огромного количества удобств и классных инструментов, таких как LINQ и EF в .NET.

Рекомендуется для ознакомления обсуждение на [Reddit](https://www.reddit.com/r/Blazor/comments/17irng3/blazor_the_end_of_react/?rdt=42081)

### Мемоизация - способ снизить вычислительную нагрузку

Предположим, что у нас в JSX определена кнопка:

```jsx
const [counter, setCounter] = useState(0);
const increase = () => setCounter((s) => s + 1);

return(
    <div>
        <FancyButton onClick={increase}>
            Increase counter
        </FancyButton>
        <Counter value={counter} />
    </div>
);

const Counter = ({value}) => {
    return <div>{value}</div>;
};

const FancyButton = ({onClick, children}) => {
    return <button onClick={onClick}>{children}</button>;
};
```

Первое, что мы можем сделать - избежать создания новой функции setCounter() при каждом нажатии на FancyButton. Для этого мы можем добавить useCallback():

```jsx
const [counter, setCounter] = useState(0);
const increase = useCallback(() => setCounter((s) => s + 1), [setCounter]);
```

Вызов useCallback() сохранит функцию, указанную в первом параметре в React и при следующем вызове, вернёт её из React-а. Однако, при втором и последующих рендерах анониманая функция с `setCounter((s) => s + 1)` всё равно будет определена. После того, как она будет определена, она будет передана в React и React её отбросит, вернув самый первый вариант функции. Т.к. конкретно в данном случае, никакой реальной оптимизации не будет, т.к. функция всё равно будет определена, а затем проигнорирована React-ом. По сути, мы даже ухудшили производительность и увеличили размер памяти для хранения данных React.

Реальный смысл использования useCallback() есть при его совместном использовании с memo. Чтобы получить реальный выигрыщ, нам нужно мемоизировать FancyButton:

```jsx
const FancyButton = React.memo(({onClick, children}) => {
    return <button onClick={onClick}>{children}</button>;
});
```

Сделав так, мы указываем React-у, что кусочек RenderTree, генерируемый FancyButton должен создаваться по новой только в том случае, если у нас изменяется либо onClick, либо children.

И вот тут возникает **самый важный момент** в мемоизации: функция FancyButton не будет генерироваться снова если функция onClick и children не поменяются. И поскольку мы использовали useCallback() для мемоизации функции increase, React использует ранее сформированную FancyButton, а не новую. Совместное использование useCallback() и React.memo() позволит экономить время на повторном рендеринге FancyButton(), хотя функция `() => setCounter((s) => s + 1)` всё равно будет создаваться при каждом рендеринге. Жертвуя малым, мы экономим на большом.

### useMemo()

React.memo() позволяет нам избежать повторного создания функции. useMemo(), в свою очередь, ориентирован на сохранение не функции, а результата её работы.

Допустим, что у нас есть компонент, который генерируем список:

```ts
const UsersList = ({ users }) => {
    return <div>
            <List items={users} />
        </div>;
};

const List = React.memo(({items}) => {
    return items.map(({ id, value}) => <div key={id}>{value}</div>)
});
```

Допустим, мы хотим отображать данные из списка по некоторому условию. Наш код мог бы быть изменён следующим образом:

```ts
const UsersList = ({ users }) => {
    const visibleUsers = users.filter(({ visible }) => visible);
    return <div>
            <List items={visibleUsers} />
        </div>;
};
```

И в этом случае, React.memo() становится совершенно бесполезным, т.к. при каждом выполнении users.filter() мы будем получать новый вариант контейнера (хотя данные будут теми же самыми) и это будет приводить к тому, что при каждой смене состояния компонент UsersList будет полностью перерисовываться. Т.е. React.memo() вместо пользы, начнёт приносить вред, из-за лишнего вызова и расхода памяти в области React-а.

Чтобы у нас действительно появилось улучшение, нужно избегать того, чтобы каждый вызов users.filter() возвращал нам новый список. Для этого и используется useMemo():

```ts
const visibleUsers = useMemo (() => users.filter(({ visible }) => visible), [users]);
```

>Главный вывод: мемоизация - инструмент, который требует от разработчика очень хорошего понимания того, что происходит "под капотом", потому, что при неудачном использовании (которое очень вероятно), производительность приложение не будет улучшена, а скорее всего - сильно ухудшена.
>При выполнении code review следует смотреть на то, используются ли useMemo() и useCallback() без React.memo(). Если используются, что нужно очень
внимательно анализировать код компонента.
