# Что мне не понравилось в React, в моём примере

Модель рендеринга React обладает низкой вычислительной эффективностью. Основные причин две:

- однопоточность (асинхронность помогает лишь отчасти)
- полный ре-рендеринг компонентов при возникновении изменений (мемоизация помогает лишь отчасти)

Рекомендуется просмотр видео [React мемоизация - useCallback, useMemo, memo](https://rutube.ru/video/4c3df952aa240c1a653a6884718bea82/) by "
Позитивный подъем".

Рендеринг компонента - это выполнение JavaScript-кода, размещённого внутри этого компонента, включая JavaScript-код, который создаётся транспиляцией TSX в многоступенчатые вызовы React.createElement(). Например, при рендеринге/повторном рендеринге компонента EmployeeModal будут создаваться контексты выполнения для всех вызовов внутри функции EmployeeModal(). В случае использования состояний (useState()), создаваемые функции не будут сохраняться в области данных React, но создаваться они всё равно будут. Отчасти проблема может быть решена посредством мемоизации, но этот вид оптимизации необходимо выявлять вручную, вручную мемоизировать (React.memo(), useCallback()), а затем вручную проверять её эффективность.

>Возможно, ситуация улучшилась в React 19, но уверенности в этом нет.

Т.е. любая активность, связанная с пользовательским интерфейсом, будет приводить к значительному расходу вычислительных ресурсов, гигантская часть которых будет расходоваться впустую, т.к. React будет отвергать сгенерированные функции.

Мы можем говорить о том, что действия, связанные с пользовательским интерфейсом инициируются "медленным" человеком, а ресурсов современного компьютера достаточно, чтобы спокойно отнестись к холостой работе процессора в кратковременные моменты времени, но вычислительные возможности компьютеров тоже бывают разными.

Так же следует обратить внимание, что React хранить VirtualDOM, состояния и ещё кучу всего в оперативной памяти, что приводит к её повышенному расходу. Это опять же, может быть не заметно на современных компьютерах, но существуют компьютеры, на которых недостаток памяти может приводить и к серьёзным проблемам с производительностью.

Резюмируя: вычислительная эффективность React крайне низкая.

## Компонентная модель, в целом - здорово, но очень много избыточности

Под избыточностью я подразумеваю огромные списки props дочерних компонентов. Даже в простом случае модального диалога, мы получаем целую кучу props, которые используются в родительском компоненте:

```tsx
<EmployeeModal 
    isOpen={isModalOpen}
    isEditMode={isEditMode}
    setModalShow={setModalShow}
    surnameField={surname} 
    setSurnameField={setSurname} 
    positionField={position} 
    setPositionField={setPosition}
    onSubmit={handleSubmit}
/>
```

А также определяются в дочерних компонентах:

```tsx
type ModalComponentProps = {
    isOpen: boolean;
    isEditMode: boolean;
    setModalShow: (state: boolean) => void;
    surnameField: string;
    setSurnameField: React.Dispatch<React.SetStateAction<string>>;
    positionField: string;
    setPositionField: React.Dispatch<React.SetStateAction<string>>;
    onSubmit: () => void;
};

const EmployeeModal: React.FC<ModalComponentProps> = ({ 
    isOpen, isEditMode, setModalShow, surnameField, setSurnameField, positionField, setPositionField, onSubmit,
}) => {
```

## Вынос состояния в родительский компонент - OK, но не совсем

Состояния определяются в родительском окне и передаются через props в дочерние:

```ts
function App() {

    // Определяем состояние "активатор модального окна"
    const [isModalOpen, setModalShow] = useState(false);

    // Определяем режим работы модального окна
    const [isEditMode, setEditMode] = useState(false);

    // Определяем состояния полей для ввода ФИО и должности
    const [surname, setSurname] = useState<string>('');
    const [position, setPosition] = useState<string>('');
```

Это лишь отчасти напоминает шаблон проектирования MVVM. В MVVM есть ModelView, в котором находятся все необходимые атрибуты, разные Views могут использовать один общий ModelView и передавать каждому дочернему компоненты все необходимые ему свойства через props не нужно.

Подход React выглядит избыточным. Допускаю, что в сложных формах он может быть чрезвычайно избыточным.

## К "синтаксическому сахару" можно привыкнуть, но он не очевидный

Пример:

```tsx
<Modal.Title>
    {isEditMode === false && (
        <>Добавление нового сотрудника</>
    )}
    {isEditMode === true && (
        <>Редактирование сотрудника</>
    )}
</Modal.Title>
```

Привыкнуть можно, но выглядит это как китайский иероглиф, т.е. его придётся выучить, он не очевиден сам по себе.

## Вызов методов дочерних компонентов требует значительных усилий

Императивный стиль программирования React не любит, предпочитая декларативный. Однако в сложных приложениях избежать использования императивного стиля невозможно.

См.: forwardRef, useImperativeHandle, Ref.

Существуют компоненты, которые предоставляют API, а не только props. Хороший пример - таблица DataTables.NET.

Нужно определить экспортируемый тип, затем использовать useImperativeHandle(), чтобы _to expose_ функции родительскому элементу. Родитель также должен использовать useRef(), чтобы воспользоваться методами дочернего компонента.

## Что же в React есть хорошего?

React реализует компонентную модель и она работает. Но она медленная и работает со значимыми ограничениями.

TypeScript работает хорошо. AutoComplete в VSCode - надёжный, проверки типов Linter-ом даёт ложные срабатывания, но, в целом, работает.
