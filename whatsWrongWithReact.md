# Что мне не понравилось в React, в моём примере

Модель рендеринга React обладает низкой вычислительной эффективностью. Основные причин две:

- однопоточность (асинхронность помогает лишь отчасти)
- полный ре-рендеринг компонентов при возникновении изменений (мемоизация помогает лишь отчасти)

Рекомендуется просмотр видео [React мемоизация - useCallback, useMemo, memo](https://rutube.ru/video/4c3df952aa240c1a653a6884718bea82/) by "
Позитивный подъем".

Рендеринг компонента - это выполнение JavaScript-кода, размещённого внутри этого компонента, включая JavaScript-код, который создаётся транспиляцией TSX в многоступенчатые вызовы React.createElement(). Например, при рендеринге/повторном рендеринге компонента EmployeeModal будут создаваться контексты выполнения для всех вызовов внутри функции EmployeeModal(). В случае использования состояний (useState()), создаваемые функции не будут сохраняться в области данных React, но создаваться они всё равно будут. Отчасти проблема может быть решена посредством мемоизации, но этот вид оптимизации необходимо выявлять вручную, вручную мемоизировать (React.memo(), useCallback()), а затем вручную проверять её эффективность.

>Возможно, ситуация улучшилась в React 19, но уверенности в этом нет.

Т.е. любая активность, связанная с пользовательским интерфейсом, будет приводить к значительному расходу вычислительных ресурсов, гигантская часть которых будет расходоваться впустую, т.к. React будет отвергать сгенерированные функции.

Мы можем говорить о том, что действия, связанные с пользовательским интерфейсом инициируются "медленным" человеком, а ресурсов современного компьютера достаточно, чтобы спокойно отнестись к холостой работе процессора в кратковременные моменты времени, но вычислительные возможности компьютеров тоже бывают разными.

Так же следует обратить внимание, что React хранит VirtualDOM, состояния и ещё кучу всего в оперативной памяти, что приводит к её повышенному расходу. Это опять же, может быть не заметно на современных компьютерах, но существуют компьютеры, на которых недостаток памяти может приводить и к серьёзным проблемам с производительностью.

Резюмируя: вычислительная эффективность React крайне низкая.

## Компонентная модель, в целом - здорово, но очень много избыточности

Под избыточностью я подразумеваю огромные списки props дочерних компонентов. Даже в простом случае модального диалога, мы получаем целую кучу props, которые используются в родительском компоненте:

```tsx
<EmployeeModal 
    isOpen={isModalOpen}
    isEditMode={isEditMode}
    setModalShow={setModalShow}
    surnameField={surname} 
    setSurnameField={setSurname} 
    positionField={position} 
    setPositionField={setPosition}
    onSubmit={handleSubmit}
/>
```

А также определяются в дочерних компонентах:

```tsx
type ModalComponentProps = {
    isOpen: boolean;
    isEditMode: boolean;
    setModalShow: (state: boolean) => void;
    surnameField: string;
    setSurnameField: React.Dispatch<React.SetStateAction<string>>;
    positionField: string;
    setPositionField: React.Dispatch<React.SetStateAction<string>>;
    onSubmit: () => void;
};

const EmployeeModal: React.FC<ModalComponentProps> = ({ 
    isOpen, isEditMode, setModalShow, surnameField, setSurnameField, positionField, setPositionField, onSubmit,
}) => {
```

## Вынос состояния в родительский компонент - OK, но не совсем

Состояния определяются в родительском окне и передаются через props в дочерние:

```ts
function App() {

    // Определяем состояние "активатор модального окна"
    const [isModalOpen, setModalShow] = useState(false);

    // Определяем режим работы модального окна
    const [isEditMode, setEditMode] = useState(false);

    // Определяем состояния полей для ввода ФИО и должности
    const [surname, setSurname] = useState<string>('');
    const [position, setPosition] = useState<string>('');
```

Это лишь отчасти напоминает шаблон проектирования MVVM. В MVVM есть ModelView, в котором находятся все необходимые атрибуты, разные Views могут использовать один общий ModelView и передавать каждому дочернему компоненты все необходимые ему свойства через props не нужно.

Подход React выглядит избыточным. Допускаю, что в сложных формах он может быть чрезвычайно избыточным.

## К "синтаксическому сахару" можно привыкнуть, но он не очевидный

Пример:

```tsx
<Modal.Title>
    {isEditMode === false && (
        <>Добавление нового сотрудника</>
    )}
    {isEditMode === true && (
        <>Редактирование сотрудника</>
    )}
</Modal.Title>
```

Привыкнуть можно, но выглядит это как китайский иероглиф, т.е. его придётся выучить, он не очевиден сам по себе.

## Вызов методов дочерних компонентов требует значительных усилий

Императивный стиль программирования React не любит, предпочитая декларативный. Однако в сложных приложениях избежать использования императивного стиля невозможно.

См.: forwardRef, useImperativeHandle, Ref.

Существуют компоненты, которые предоставляют API, а не только props. Хороший пример - таблица DataTables.NET.

Нужно определить экспортируемый тип, затем использовать useImperativeHandle(), чтобы _to expose_ функции родительскому элементу. Родитель также должен использовать useRef(), чтобы воспользоваться методами дочернего компонента.

## Что же в React есть хорошего?

React реализует компонентную модель и она работает. Но она медленная и работает со значимыми ограничениями.

TypeScript работает хорошо. AutoComplete в VSCode - надёжный, проверки типов Linter-ом даёт ложные срабатывания, но, в целом, работает.

Интеграция с Bootstrap 5 и DataTables.NET, на мой взгляд, на четыре с плюсом. Один плюсик потерян из-за того, что есть множество не очевидных моментов, которые приходится искать (иногда с большим трудом).

Несомненно, к хорошему можно отнести Plug-in для Chrome **React Developer Tools**, который позволяет просматривать структуру VirtualDOM, данные, которые хранит React, а также содержит Profiler, посредством которого можно оценивать, рендеринг какого из компоненентов занял больше всего времени в конкретный re-render. Создаётся впечатление, что DevTool действительно очень хороший, полезный инструмент.

## Оценка будущего React

В 2025 году, всё совсем не однозначно. Основная проблема инструмента - фрагментация. Ключевое направление развития React - SSR (Server-Side Rendering), решающий многие из проблем существующих React-приложений.

Три вещи, которые нужны для работы SSR:

- Bundler, который умеет разделять код на серверные и клиентские компоненты
- Server, который загружает js bundle, формирует контент и передаёт его клиентскому компоненту
- Client-Side Router, который умеет разделять трафик на клиентский и серверный

Проблема состоит в том, что React/SSR нарушает идеоматический способ разработки React-приложений. Более того, развитие различных React/SSR библиотек очень сильно ломает общую концепцию, библиотеки все более и более не совместимым друг с другом. Т.е. выбирая React в качестве основной платформы разработчики должны выбрать "традиционный React", или SSR, а потом ещё и угадать, какую с SSR-библиотек использовать. С учётом жёсткой конкуренции между разработчиками альтернативных библиотек, вероятность принятия правильного решения (LTS проекта на 10 лет) в этой "угадайке" не очень высокая.

При этом, тот факт, что React/SSR ориентируется на Node.js на стороне сервера - это сильный сдерживающий фактор, т.к. оставляет "за бортом" растущие эко-системы: Go lang, .NET Core, Rust, Java Next.

Дополнительно, есть существенное давление со стороны альтернативных разработок:

- Vue.js (на подъёме)
- Angular (падение, но пока не свободное)
- Svelte, Blazor (странная, леворезьбовая история)
- развитие экосистемы WASM

Из приведённых выше, наиболее опасным для React является развитие Vue.js
